"use strict";(self.webpackChunkbifromq=self.webpackChunkbifromq||[]).push([[2546],{13637:(e,i,t)=>{t.d(i,{A:()=>n});const n=t.p+"assets/images/BifroMQ-StandardCluster-2b113e969e5221e21edecc3066e095f7.png"},30549:(e,i,t)=>{t.d(i,{A:()=>n});const n=t.p+"assets/images/BifroMQ-Inbox-SubCluster-090bd2a05007aa5b87bd2143430e52c2.png"},50517:(e,i,t)=>{t.d(i,{A:()=>n});const n=t.p+"assets/images/BifroMQ-Inbox-LoadBasedSplitter-e07655f230338ef623d03737386be337.png"},64935:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>f,contentTitle:()=>h,default:()=>g,frontMatter:()=>u,metadata:()=>n,toc:()=>p});var n=t(79225),o=t(23420),s=t(65404),r=t(13637),a=t(89339),l=t(30549),d=t(50517),c=t(66916);const u={slug:"bifromq-standardcluster",title:"BifroMQ StandardCluster",authors:"HaoYu",tags:["BifroMQ","Open Source","MQTT","Cluster"]},h="Introduction",f={authorsImageUrls:[void 0]},p=[{value:"TLDR:",id:"tldr",level:2},{value:"Overall Structure of the Standard Cluster",id:"overall-structure-of-the-standard-cluster",level:2},{value:"Horizontal Scaling of Message Distribution Capability",id:"horizontal-scaling-of-message-distribution-capability",level:2},{value:"Persistence, Scalability, and High Reliability of Offline Message Queues",id:"persistence-scalability-and-high-reliability-of-offline-message-queues",level:2},{value:"Load-Based Splitting Strategy for Inbox Service",id:"load-based-splitting-strategy-for-inbox-service",level:2},{value:"HTTP API Module",id:"http-api-module",level:2},{value:"Impact of Mixed Workloads on Performance",id:"impact-of-mixed-workloads-on-performance",level:2},{value:"Deployment and Operations",id:"deployment-and-operations",level:2},{value:"Future Outlook",id:"future-outlook",level:2}];function m(e){const i={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(i.p,{children:["Since the first release of BifroMQ, it has gained wide attention from the community. Among them, cluster capability has been highly anticipated and also one of the top priorities for the BifroMQ team. After three months of tireless efforts, we officially released the cluster version of BifroMQ, which we call the ",(0,o.jsx)(i.strong,{children:"Standard Cluster"}),". The Standard Cluster is the main cluster mode supported in the open source version of BifroMQ, where each node has full MQTT protocol capabilities under this mode. At the same time, HTTP API is also supported in this version"]}),"\n",(0,o.jsx)(i.h2,{id:"tldr",children:"TLDR:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["Installation ",(0,o.jsx)(i.a,{href:"https://github.com/bifromqio/bifromq/releases/",children:"package"})," and Deployment ",(0,o.jsx)(i.a,{href:"/docs/cluster/standardcluster/",children:"instructions"})]}),"\n"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:["API ",(0,o.jsx)(i.a,{href:"/docs/user_guide/api/intro/",children:"documentation"})]}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"overall-structure-of-the-standard-cluster",children:"Overall Structure of the Standard Cluster"}),"\n",(0,o.jsxs)(i.p,{children:["In a previous architecture overview ",(0,o.jsx)(i.a,{href:"/blog/bifromq-tech-architecture",children:"article"}),", we mentioned that BifroMQ logically divides MQTT functionalities into several sub-services, each corresponding to a critical workload:"]}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"bifromq-mqtt: Responsible for MQTT protocol connection workloads."}),"\n",(0,o.jsx)(i.li,{children:"bifromq-dist: Manages subscription and message routing distribution workloads."}),"\n",(0,o.jsx)(i.li,{children:"bifromq-inbox: Handles offline message queues within persistent sessions."}),"\n",(0,o.jsx)(i.li,{children:"bifromq-retain: Manages the storage and retrieval of Retain messages."}),"\n"]}),"\n",(0,o.jsx)(i.p,{children:'From a deployment perspective, BifroMQ StandardCluster encapsulates these independent workload service modules into a cluster mode within a single node service process, and logically, this can be seen as an abstraction of the Standalone operating mode (BifroMQ Standalone can be considered as a single-node version of BifroMQ StandardCluster). Unlike other MQTT Brokers that support clustering, BifroMQ incorporates built-in distributed persistence functionality, making each individual BifroMQ node "stateful."'}),"\n",(0,o.jsx)("img",{src:r.A,style:{width:700}}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.em,{children:'Note: In all illustrations in this article, the text within brackets, "bifromq-xxx," corresponds to the module names in the code.'})}),"\n",(0,o.jsx)(i.h2,{id:"horizontal-scaling-of-message-distribution-capability",children:"Horizontal Scaling of Message Distribution Capability"}),"\n",(0,o.jsx)(i.p,{children:"In the Standard Cluster mode, the Dist Service module within each node process forms a logically partitioned subset cluster of workloads (Dist-SubCluster). Dist Service stores subscription information in a built-in persistence engine and synchronizes routing information between nodes using the persistence engine's distributed capabilities. In Standard Cluster mode, horizontal scaling of message distribution capability can be achieved by adding nodes, especially when CleanSession is set to True."}),"\n",(0,o.jsx)("img",{src:a.A,style:{width:700}}),"\n",(0,o.jsx)(i.h2,{id:"persistence-scalability-and-high-reliability-of-offline-message-queues",children:"Persistence, Scalability, and High Reliability of Offline Message Queues"}),"\n",(0,o.jsx)(i.p,{children:"Similar to the Dist Service module, the Inbox Service module within node processes, responsible for offline message queues within MQTT persistent sessions, forms another logically partitioned subset cluster of workloads (Inbox-SubCluster). Inbox Service persists offline queue messages in the built-in storage engine, significantly reducing data loss due to node failures. In terms of storage, Inbox Service leverages the sharding capability of the built-in storage engine, allowing horizontal scaling of storage capacity and processing power. Additionally, by dynamically increasing the number of shard replicas through static configuration or runtime policies, the reliability of offline message data can be further enhanced, which is especially important for applications with higher data reliability requirements."}),"\n",(0,o.jsx)("img",{src:l.A,style:{width:700}}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsxs)(i.em,{children:["Note 1: Due to the significant impact of increasing shard replica count on message workloads when MQTT CleanSession is set to False, resource allocation must be determined based on actual needs, with the default replica count set to 1, which can be adjusted through the JVM startup parameter ",(0,o.jsx)(i.code,{children:"inbox_store_range_voter_count"}),"."]})}),"\n",(0,o.jsx)(i.p,{children:(0,o.jsx)(i.em,{children:'Note 2: The Inbox Service provides global access to offline message queues, allowing MQTT clients to access offline messages in their respective queues when reconnecting to any cluster node, eliminating the need for the common "sticky session" or "session migration" solutions often found in other MQTT Broker cluster implementations.'})}),"\n",(0,o.jsx)(i.h2,{id:"load-based-splitting-strategy-for-inbox-service",children:"Load-Based Splitting Strategy for Inbox Service"}),"\n",(0,o.jsx)(i.p,{children:'As previously mentioned, in a Standard Cluster deployment, the Inbox Service within a single node process utilizes the sharding capability of the built-in storage engine to achieve horizontal scaling of storage capacity and processing power. However, the sharding strategy has a decisive impact on actual performance. In BifroMQ Standard Cluster, we have incorporated an out-of-the-box load-based splitting strategy. This strategy determines the partitioning of KV Ranges based on load conditions over a recent period, serving as a "posterior" splitting strategy. When the usage scenario has already been planned and understood for the distribution of offline message workloads, pre-partitioning typically results in more stable performance when the workload arrives. For advanced BifroMQ users, prior splitting strategies can be implemented through the SPI mechanism.'}),"\n",(0,o.jsx)("img",{src:d.A,style:{width:400}}),"\n",(0,o.jsx)(i.h2,{id:"http-api-module",children:"HTTP API Module"}),"\n",(0,o.jsxs)(i.p,{children:["BifroMQ StandardCluster introduces the HTTP API feature. Each cluster node can open an API access port through configuration. BifroMQ HTTP API is a stateless global interface designed to support the integration of management control logic at the business level. Accessing the API of any node allows operations on the entire cluster. For more details, please refer to ",(0,o.jsx)(i.a,{href:"/docs/user_guide/api/intro/",children:"this link"}),"."]}),"\n",(0,o.jsx)("img",{src:c.A,style:{width:700}}),"\n",(0,o.jsx)(i.h2,{id:"impact-of-mixed-workloads-on-performance",children:"Impact of Mixed Workloads on Performance"}),"\n",(0,o.jsx)(i.p,{children:"In a Standard Cluster deployment, a single node possesses complete MQTT protocol functionality, handling various types of workloads. Therefore, this mode is particularly suitable for two types of enterprise-level application scenarios:"}),"\n",(0,o.jsxs)(i.ol,{children:["\n",(0,o.jsx)(i.li,{children:"Workloads generated by the business are relatively uniform."}),"\n",(0,o.jsx)(i.li,{children:"The business generates a diverse range of workloads, but they are relatively evenly distributed in time.\nFor cases where workloads are complex and generated centrally in terms of time, we recommend that users perform load testing to determine the optimal resource configuration and parameter settings for a single BifroMQ Standard Cluster cluster or consider using multiple BifroMQ Standard Clusters to handle different types of business workloads. Additionally, you can reach out to us for support with BifroMQ Independent-Workload Cluster in the BifroMQ commercial version."}),"\n"]}),"\n",(0,o.jsx)(i.h2,{id:"deployment-and-operations",children:"Deployment and Operations"}),"\n",(0,o.jsxs)(i.p,{children:["In a previous BifroMQ technical architecture article, we mentioned that BifroMQ clusters are built on a decentralized technology (base-cluster), eliminating the need for external node registration and discovery services. As a result, the deployment process for building a BifroMQ Standard Cluster is straightforward (for detailed instructions, please refer to ",(0,o.jsx)(i.a,{href:"/docs/cluster/standardcluster/",children:"this link"}),"). It only requires designating any node in a cluster as a seed node to enable the addition of new nodes. Furthermore, BifroMQ includes self-healing capabilities in the event of cluster partitioning, greatly simplifying operational tasks during network partition and other failures."]}),"\n",(0,o.jsx)(i.h2,{id:"future-outlook",children:"Future Outlook"}),"\n",(0,o.jsxs)(i.p,{children:["The BifroMQ team adheres to a neutral technology philosophy, dedicated to the large-scale implementation of the MQTT protocol, as well as improving reliability and maintainability. We look forward to more community participation and in-depth user feedback to collectively advance this technology. Additionally, you can join the developer community by ",(0,o.jsx)(i.a,{href:"mailto:hello@bifromq.io",children:"emailing"})," us your WeChat ID, along with more information on why BifroMQ has caught your attention (we'd love to hear about it), or by joining our Discord group via this ",(0,o.jsx)(i.a,{href:"https://discord.gg/Pfs3QRadRB",children:"link"}),"."]})]})}function g(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},65404:(e,i,t)=>{t.d(i,{R:()=>r,x:()=>a});var n=t(36672);const o={},s=n.createContext(o);function r(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(s.Provider,{value:i},e.children)}},66916:(e,i,t)=>{t.d(i,{A:()=>n});const n=t.p+"assets/images/BifroMQ-API-Service-b5239853399fb4f76c1db7496a3ccc3c.png"},79225:e=>{e.exports=JSON.parse('{"permalink":"/blog/bifromq-standardcluster","editUrl":"https://github.com/apache/bifromq-sites/tree/master/website/blog","source":"@site/blog/2023-10-24-bifromq-standardcluster.mdx","title":"BifroMQ StandardCluster","description":"Since the first release of BifroMQ, it has gained wide attention from the community. Among them, cluster capability has been highly anticipated and also one of the top priorities for the BifroMQ team. After three months of tireless efforts, we officially released the cluster version of BifroMQ, which we call the Standard Cluster. The Standard Cluster is the main cluster mode supported in the open source version of BifroMQ, where each node has full MQTT protocol capabilities under this mode. At the same time, HTTP API is also supported in this version","date":"2023-10-24T00:00:00.000Z","tags":[{"inline":true,"label":"BifroMQ","permalink":"/blog/tags/bifro-mq"},{"inline":true,"label":"Open Source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"MQTT","permalink":"/blog/tags/mqtt"},{"inline":true,"label":"Cluster","permalink":"/blog/tags/cluster"}],"readingTime":5.94,"hasTruncateMarker":true,"authors":[{"name":"Yonny(Yu) Hao","url":"https://github.com/popduke","imageURL":"https://github.com/popduke.png","key":"HaoYu","page":null}],"frontMatter":{"slug":"bifromq-standardcluster","title":"BifroMQ StandardCluster","authors":"HaoYu","tags":["BifroMQ","Open Source","MQTT","Cluster"]},"unlisted":false,"prevItem":{"title":"BifroMQ: Unveiling the Technology for Building Efficient and Available Clusters","permalink":"/blog/bifromq-high-availibility"},"nextItem":{"title":"BifroMQ Technical Architecture Overview","permalink":"/blog/bifromq-tech-architecture"}}')},89339:(e,i,t)=>{t.d(i,{A:()=>n});const n=t.p+"assets/images/BifroMQ-Dist-SubCluster-b0cf7d6570b2aaef74275f799ebc3c24.png"}}]);