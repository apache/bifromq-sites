"use strict";(self.webpackChunkBifroMQ=self.webpackChunkBifroMQ||[]).push([[5538],{33162:e=>{e.exports=JSON.parse('{"permalink":"/blog/bifromq-tech-architecture","editUrl":"https://github.com/apache/bifromq-sites/tree/master/website/blog","source":"@site/blog/2023-09-06-bifromq-architecture-overview.md","title":"BifroMQ Technical Architecture Overview","description":"In today\'s IoT field, the MQTT protocol has become an indispensable key element, providing core technical support for efficient and real-time data transmission. However, projects that currently offer MQTT capabilities are mainly concentrated on traditional, existing \\"out-of-the-box\\" IoT device management platforms, leading to a lack of sufficient attention and exploration of the underlying MQTT protocol implementation. However, we firmly believe that the characteristics of the MQTT protocol have a broader application prospect, not limited to the IoT field. It is out of this belief that after years of practice and technical accumulation, we have launched the open-source project BifroMQ, focusing on the efficient processing of the MQTT protocol, especially in the face of large-scale loads.","date":"2023-09-06T00:00:00.000Z","tags":[{"inline":true,"label":"BifroMQ","permalink":"/blog/tags/bifro-mq"},{"inline":true,"label":"MQTT Broker","permalink":"/blog/tags/mqtt-broker"},{"inline":true,"label":"Serverless","permalink":"/blog/tags/serverless"},{"inline":true,"label":"Multi-Tenancy","permalink":"/blog/tags/multi-tenancy"},{"inline":true,"label":"Architecture","permalink":"/blog/tags/architecture"}],"readingTime":7.36,"hasTruncateMarker":true,"authors":[{"name":"Yonny(Yu) Hao","url":"https://github.com/popduke","imageURL":"https://github.com/popduke.png","key":"HaoYu","page":null}],"frontMatter":{"slug":"bifromq-tech-architecture","title":"BifroMQ Technical Architecture Overview","authors":"HaoYu","tags":["BifroMQ","MQTT Broker","Serverless","Multi-Tenancy","Architecture"]},"unlisted":false,"prevItem":{"title":"BifroMQ StandardCluster","permalink":"/blog/bifromq-standardcluster"},"nextItem":{"title":"AnyAuth and Integration with BifroMQ","permalink":"/blog/AnyAuth and Integration with BifroMQ"}}')},39319:(e,t,i)=>{i.d(t,{A:()=>o});const o=i.p+"assets/images/bifromq-architecture-2-1-7d0c9e677ec8f66289475f074bf35aaf.png"},41470:(e,t,i)=>{i.d(t,{A:()=>o});const o=i.p+"assets/images/bifromq-architecture-1-99ffa619fa5852e0ace0ae49e41c7ff0.png"},50220:(e,t,i)=>{i.d(t,{A:()=>o});const o=i.p+"assets/images/bifromq-architecture-3-c4baa6efcc8cda4dfc1c2879edf594c2.png"},55036:(e,t,i)=>{i.d(t,{A:()=>o});const o=i.p+"assets/images/bifromq-architecture-2-2-092f9df6525b74a1165ef9257f37809e.png"},65404:(e,t,i)=>{i.d(t,{R:()=>s,x:()=>a});var o=i(36672);const n={},r=o.createContext(n);function s(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),o.createElement(r.Provider,{value:t},e.children)}},92383:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var o=i(33162),n=i(23420),r=i(65404);const s={slug:"bifromq-tech-architecture",title:"BifroMQ Technical Architecture Overview",authors:"HaoYu",tags:["BifroMQ","MQTT Broker","Serverless","Multi-Tenancy","Architecture"]},a="BifroMQ Technical Architecture Overview",l={authorsImageUrls:[void 0]},c=[{value:"Building Large-Scale Multi-Tenant Serverless Cloud Services",id:"building-large-scale-multi-tenant-serverless-cloud-services",level:2},{value:"Enterprise Deployment: Flexibility and Robustness",id:"enterprise-deployment-flexibility-and-robustness",level:2},{value:"BifroMQ Architecture Analysis",id:"bifromq-architecture-analysis",level:2},{value:"Modular Architecture Based on Decentralized Cluster Management",id:"modular-architecture-based-on-decentralized-cluster-management",level:3},{value:"Modular Load Isolation and Collaboration",id:"modular-load-isolation-and-collaboration",level:3},{value:"Neutrality: Standard-Oriented and Scalable Integration",id:"neutrality-standard-oriented-and-scalable-integration",level:3},{value:"Summary",id:"summary",level:3}];function d(e){const t={h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:'In today\'s IoT field, the MQTT protocol has become an indispensable key element, providing core technical support for efficient and real-time data transmission. However, projects that currently offer MQTT capabilities are mainly concentrated on traditional, existing "out-of-the-box" IoT device management platforms, leading to a lack of sufficient attention and exploration of the underlying MQTT protocol implementation. However, we firmly believe that the characteristics of the MQTT protocol have a broader application prospect, not limited to the IoT field. It is out of this belief that after years of practice and technical accumulation, we have launched the open-source project BifroMQ, focusing on the efficient processing of the MQTT protocol, especially in the face of large-scale loads.'}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Neutral and Scalable MQTT Protocol Middleware"})}),"\n",(0,n.jsx)(t.p,{children:'Compared to traditional IoT device management platforms, BifroMQ adheres to a different design philosophy. We boldly abandon the traditional paradigm of "one-size-fits-all solutions" and focus on the needs of high-performance MQTT protocols. We believe that the characteristics of the MQTT protocol have a broader application paradigm, so BifroMQ is committed to fully exploiting the potential of the MQTT protocol, especially in terms of excellent performance when handling large-scale loads.'}),"\n",(0,n.jsx)(t.p,{children:'Compared to integrating logic with downstream systems (such as Kafka) in MQTT implementations, BifroMQ prefers to "dock" with downstream systems in a way that complies with MQTT standards. For example, through the Shared Subscription mechanism, the integration logic is externalized to achieve more decoupled bridging and the ability to forward messages to heterogeneous systems while maintaining high message throughput. This design philosophy makes BifroMQ a highly customizable middleware that can easily adapt to various downstream systems to meet the needs of different business scenarios.'}),"\n",(0,n.jsx)(t.h2,{id:"building-large-scale-multi-tenant-serverless-cloud-services",children:"Building Large-Scale Multi-Tenant Serverless Cloud Services"}),"\n",(0,n.jsx)(t.p,{children:'The mission of BifroMQ is to build an MQTT messaging system suitable for large-scale multi-tenant use to support the business characteristics of Serverless-type cloud services. This mission is driven by a deep understanding of the characteristics of the MQTT protocol and confidence in its broader application. Unlike traditional enterprise architectures, Serverless cloud services emphasize resource allocation on demand, elastic expansion, and highly flexible service construction. Therefore, BifroMQ, through its multi-tenant architecture and resource sharing mechanism, provides the feature of "shared resources, exclusive experience" for Serverless-type businesses.'}),"\n",(0,n.jsx)(t.h2,{id:"enterprise-deployment-flexibility-and-robustness",children:"Enterprise Deployment: Flexibility and Robustness"}),"\n",(0,n.jsx)(t.p,{children:'Although the goal of BifroMQ is to build multi-tenant Serverless cloud services, multi-tenant + shared resources are essentially an abstraction of single-tenant exclusive resources. Consistent with our philosophy, BifroMQ easily supports common "Shared Nothing" enterprise-level cluster deployments through the free combination and configuration of core components. In fact, this is also the default deployment mode of the open-source version of BifroMQ. This flexibility allows BifroMQ to adapt to system architectures of various scales and needs.'}),"\n",(0,n.jsx)(t.h2,{id:"bifromq-architecture-analysis",children:"BifroMQ Architecture Analysis"}),"\n",(0,n.jsx)(t.p,{children:'The architectural design of BifroMQ is based on "first principles," analyzing the technologies needed to achieve design goals from a technical perspective and how to organically combine these technologies to achieve overall optimization. Therefore, it is difficult to fully understand its connotation just from the project structure and code logic. The following will describe the overall architecture of BifroMQ from three main angles.'}),"\n",(0,n.jsx)(t.h3,{id:"modular-architecture-based-on-decentralized-cluster-management",children:"Modular Architecture Based on Decentralized Cluster Management"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Firstly"}),", apart from the implementation logic of the MQTT protocol itself, the various functional service modules of BifroMQ are built on a set of decentralized underlying cluster construction capabilities (base-cluster), as shown in the following figure:"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Modular architecture of BifroMQ&#39;s decentralized cluster",src:i(41470).A+"",width:"1521",height:"876"})}),"\n",(0,n.jsx)("p",{class:"text-gray-400 text-center",children:"Modular architecture of BifroMQ's decentralized cluster"}),"\n",(0,n.jsx)(t.p,{children:'The cluster logic constructed by base-cluster is logically divided into two layers: Underlay Cluster and Overlay Cluster. The Underlay Cluster is called the "Host" Cluster, and each Host in BifroMQ corresponds to a service process (Process) running on the operating system. The Host Cluster uses Gossip-like protocols (SWIM Protocol) to implement Host Membership and provides an abstract Host address for the Overlay Cluster. The Overlay Cluster is called the "Agent" Cluster, which provides an Agent-level address abstraction (Agent Address) based on the Host address. In BifroMQ, the Agent corresponds to a logical service (Service) that implements specific functions. These logical services (unifiedly implemented through the base-rpc framework) include client and server role modules, which use the capabilities of the Agent Cluster to achieve service registration and discovery.'}),"\n",(0,n.jsx)(t.p,{children:"The benefits of this architecture include:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Logical services are decoupled from the processes in which they are located, allowing for more flexible encapsulation and combination according to deployment scenarios."}),"\n",(0,n.jsx)(t.li,{children:'The "service discovery" of logical services does not depend on traditional registration centers or name services, thereby eliminating the operational risk of single-point failures and allowing the cluster scale to freely expand.'}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"modular-load-isolation-and-collaboration",children:"Modular Load Isolation and Collaboration"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.strong,{children:"Next"}),", we describe the structure of BifroMQ from the perspective of protocol implementation. When architecting from the perspective of building Serverless cloud services, it is necessary to consider the rationality of functional implementation from the perspective of load isolation and management, that is, the multi-tenancy of the load. We have split the workload of the MQTT protocol so that each type of load can exist in the form of an independent sub-cluster, and these sub-clusters build complete MQTT capabilities through collaboration. The following are the MQTT load-related modules in BifroMQ:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"bifromq-mqtt: Responsible for handling the long-connection load of the MQTT protocol"}),"\n",(0,n.jsx)(t.li,{children:"bifromq-dist: Responsible for maintaining the high-reliability storage and large-scale message routing of MQTT subscription status"}),"\n",(0,n.jsx)(t.li,{children:"bifromq-inbox: Responsible for the high-reliability storage of subscriber session messages in CleanSession=false mode"}),"\n",(0,n.jsx)(t.li,{children:"bifromq-retain: Responsible for the high-reliability storage of Retain messages"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The collaboration relationship between these modules is shown in the following figures:"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.img,{alt:"BifroMQ Module Collaboration Relationship 1",src:i(39319).A+"",width:"1266",height:"779"}),"\n",(0,n.jsx)(t.img,{alt:"BifroMQ Module Collaboration Relationship 2",src:i(55036).A+"",width:"1417",height:"781"})]}),"\n",(0,n.jsx)("p",{class:"text-gray-400 text-center",children:"BifroMQ Module Collaboration Relationship"}),"\n",(0,n.jsx)(t.p,{children:"It is worth mentioning that the bifromq-dist, bifromq-inbox, and bifromq-retain modules all make full use of the capabilities of base-kv to achieve distributed strong consistency persistence of key loads. In the operation and maintenance scenarios of Serverless cloud services, this is particularly important for ensuring SLA."}),"\n",(0,n.jsx)(t.h3,{id:"neutrality-standard-oriented-and-scalable-integration",children:"Neutrality: Standard-Oriented and Scalable Integration"}),"\n",(0,n.jsx)(t.p,{children:'As mentioned earlier, the positioning of BifroMQ is to implement MQTT standard middleware, emphasizing neutrality and integrability more. It is not on the same level as other projects that include MQTT capabilities as part of a "one-size-fits-all IoT platform."'}),"\n",(0,n.jsx)(t.p,{children:'Therefore, the standard for judging "whether BifroMQ has a certain function or will support a certain function in the future?" is very simple: all capabilities defined by the MQTT protocol belong to the scope that the BifroMQ project needs to support, and all functions that exceed the definition of the MQTT protocol, we prefer to exist as independent components or services, and integrate with BifroMQ in a way that complies with MQTT standards. This method helps to build larger-scale cloud services and promote the maturity of related technologies.'}),"\n",(0,n.jsx)(t.p,{children:"Of course, the integrability of BifroMQ is also reflected in the integration of the middleware itself with various business systems, mainly including three mechanisms: Plugin, API, and Metrics:"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Typical Scenario Integration Architecture",src:i(50220).A+"",width:"1205",height:"757"})}),"\n",(0,n.jsx)("p",{class:"text-gray-400 text-center",children:"Typical Scenario Integration Architecture"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The Plugin mechanism is the main way to implement business logic integration. bifromq currently defines the following plugin interface modules:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"bifromq-plugin-auth-provider: Implement client authentication and Pub/Sub authorization logic based on message topics"}),"\n",(0,n.jsx)(t.li,{children:"bifromq-plugin-event-collector: Implement business logic triggered by various MQTT-related events"}),"\n",(0,n.jsx)(t.li,{children:"bifromq-plugin-setting-provider: Implement tenant-level runtime setting change management logic"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Reference implementations of these interfaces can be found in the BifroMQ-Inside project."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The API mechanism (coming soon) provides BifroMQ's runtime HTTP management interface, implementing basic management operations such as server-side subscription management and disconnection."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"The Metrics mechanism implements metric definition and sampling through the use of the micrometer library, but does not limit the type of collector, allowing business integration parties to customize (you can refer to the build-plugin-demo module in the project)."}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"summary",children:"Summary"}),"\n",(0,n.jsxs)(t.p,{children:["In summary, this is an overall introduction to the technical architecture of BifroMQ. Please look forward to a series of special articles that we will publish next, to explore the various components and design principles of BifroMQ in depth. At the same time, you are welcome to join the BifroMQ Discord  ",(0,n.jsx)("a",{href:"https://discord.gg/Pfs3QRadRB",children:(0,n.jsx)("img",{src:"https://img.shields.io/discord/1115542029531885599?logo=discord&logoColor=white",alt:"BifroMQ Discord server"})}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);