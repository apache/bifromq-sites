"use strict";(self.webpackChunkbifromq=self.webpackChunkbifromq||[]).push([[21357],{53546:(e,s,i)=>{i.d(s,{R:()=>t,x:()=>c});var n=i(59729);const r={},o=n.createContext(r);function t(e){const s=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),n.createElement(o.Provider,{value:s},e.children)}},74428:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>a,frontMatter:()=>t,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"user_guide/basic/pubsub","title":"Pub/Sub","description":"According to the MQTT protocol, entities involved in sending and receiving messages can be categorized as Publishers and Subscribers. The basic model is depicted below:","source":"@site/docs/user_guide/basic/pubsub.md","sourceDirName":"user_guide/basic","slug":"/user_guide/basic/pubsub","permalink":"/docs/user_guide/basic/pubsub","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/docs/user_guide/basic/pubsub.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Pub/Sub"},"sidebar":"tutorialSidebar","previous":{"title":"Connect to BifroMQ","permalink":"/docs/user_guide/basic/connect"},"next":{"title":"Shared Subscriptions","permalink":"/docs/user_guide/basic/shared_sub"}}');var r=i(65813),o=i(53546);const t={sidebar_position:2,title:"Pub/Sub"},c=void 0,d={},l=[];function h(e){const s={code:"code",li:"li",mermaid:"mermaid",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"According to the MQTT protocol, entities involved in sending and receiving messages can be categorized as Publishers and Subscribers. The basic model is depicted below:"}),"\n",(0,r.jsx)(s.mermaid,{value:'graph LR\n\n  subgraph "MQTT Clients"\n    Sensor0(Sensor0)\n    Sensor1(Sensor1)\n    Sensor2(Sensor2)\n  end\n\n  subgraph "MQTT Clients"\n    Process0(Process0)\n    Process1(Process1)\n  end\n\n  BifroMQ(BifroMQ)\n\n  Sensor0 --\x3e|Publish 20\xb0C| BifroMQ\n  Sensor1 --\x3e BifroMQ\n  Sensor2 --\x3e BifroMQ\n\n  BifroMQ --\x3e|Publish: 20\xb0C| Process0\n  BifroMQ --\x3e Process1\n\n  Process0 -.->|Subscribe| BifroMQ'}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Publishing Messages"}),": Clients can publish messages to the server through a connection. Messages are published based on ",(0,r.jsx)(s.code,{children:"topics"}),", which describe the content of the communication and are hierarchical in nature (\ne.g., ",(0,r.jsx)(s.code,{children:"home/bedroom/temperature"}),")."]}),"\n",(0,r.jsx)(s.p,{children:"When publishing a message, clients need to specify a topic, and the message payload contains the actual content of the communication. Additionally, the publisher must specify the Quality of Service (QoS) for the message. BifroMQ supports\nall MQTT QoS levels: QoS0, QoS1, and QoS2. Their meanings are as follows:"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:"QoS"}),(0,r.jsx)(s.th,{children:"Description"})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"QoS0"}),(0,r.jsx)(s.td,{children:"At most once delivery"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"QoS1"}),(0,r.jsx)(s.td,{children:"At least once delivery"})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:"QoS2"}),(0,r.jsx)(s.td,{children:"Exactly once delivery"})]})]})]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Subscribing to Topics"}),": In subscription, the subscribed topics are called ",(0,r.jsx)(s.code,{children:"topicFilter"}),". The server receives subscription requests from clients and records these subscriptions. Generally, subscriptions can be either non-wildcard\nsubscriptions or wildcard subscriptions."]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["For ",(0,r.jsx)(s.strong,{children:"non-wildcard subscriptions"}),": Clients subscribe to a specific topic without using wildcards. For example, if a client subscribes to ",(0,r.jsx)(s.code,{children:"home/bedroom/temperature"}),", it will only match messages with the\ntopic ",(0,r.jsx)(s.code,{children:"home/bedroom/temperature"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["For ",(0,r.jsx)(s.strong,{children:"wildcard subscriptions"}),": The subscription topic includes wildcard characters (",(0,r.jsx)(s.code,{children:"+"})," or ",(0,r.jsx)(s.code,{children:"#"}),"). The ",(0,r.jsx)(s.code,{children:"+"})," wildcard matches a single level in the topic hierarchy, while the ",(0,r.jsx)(s.code,{children:"#"})," wildcard matches multiple levels. Below are examples of\nhow to use wildcards for subscriptions:"]}),"\n",(0,r.jsxs)(s.p,{children:["Using the ",(0,r.jsx)(s.code,{children:"+"})," wildcard:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Subscribing to ",(0,r.jsx)(s.code,{children:"sensor/+/temperature"})," matches topics like ",(0,r.jsx)(s.code,{children:"sensor/bedroom/temperature"}),", ",(0,r.jsx)(s.code,{children:"sensor/kitchen/temperature"}),", etc."]}),"\n",(0,r.jsxs)(s.li,{children:["Subscribing to ",(0,r.jsx)(s.code,{children:"home/+/light/+"})," matches topics like ",(0,r.jsx)(s.code,{children:"home/livingroom/light/on"}),", ",(0,r.jsx)(s.code,{children:"home/bedroom/light/off"}),", etc."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["Using the ",(0,r.jsx)(s.code,{children:"#"})," wildcard:"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Subscribing to ",(0,r.jsx)(s.code,{children:"home/bedroom/#"})," matches topics like ",(0,r.jsx)(s.code,{children:"home/bedroom/light/on"}),", ",(0,r.jsx)(s.code,{children:"home/bedroom/temperature"}),", and their subtopics."]}),"\n",(0,r.jsxs)(s.li,{children:["Subscribing to ",(0,r.jsx)(s.code,{children:"home/+/#"})," matches topics like ",(0,r.jsx)(s.code,{children:"home/bedroom/light/on"}),", ",(0,r.jsx)(s.code,{children:"home/kitchen/temperature"}),", and their subtopics."]}),"\n",(0,r.jsxs)(s.li,{children:["Subscribing to ",(0,r.jsx)(s.code,{children:"#"})," matches all topics."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Note that wildcard subscriptions can result in a large number of topics being subscribed to, so performance and resource consumption should be carefully considered when using wildcard subscriptions."}),"\n",(0,r.jsxs)(s.p,{children:["Similar to publishing messages, when subscribing to topics, the client needs to specify the QoS for that topic. BifroMQ, according to the MQTT protocol, will take the minimum of the QoS of the published message and the subscribed\ntopic when forwarding messages, i.e., ",(0,r.jsx)(s.code,{children:"Min(PublishQoS, SubscribeQoS)"}),". This means that even if the subscriber has subscribed to a topic with QoS2, it might still receive messages with QoS0."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]})]})}function a(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);