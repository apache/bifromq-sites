"use strict";(self.webpackChunkbifromq=self.webpackChunkbifromq||[]).push([[33923],{21690:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"user_guide/API/api","title":"API Service","description":"Introduction","source":"@site/versioned_docs/version-2.0.0/05_user_guide/3_API/1_api.md","sourceDirName":"05_user_guide/3_API","slug":"/user_guide/API/api","permalink":"/docs/2.0.0/user_guide/API/api","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/versioned_docs/version-2.0.0/05_user_guide/3_API/1_api.md","tags":[],"version":"2.0.0","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"API Usage","permalink":"/docs/2.0.0/category/api-usage"},"next":{"title":"Plugin","permalink":"/docs/2.0.0/category/plugin"}}');var t=n(23420),r=n(65404);const o={sidebar_position:1},l="API Service",c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Deployment",id:"deployment",level:2},{value:"List of APIs",id:"list-of-apis",level:2},{value:"Subscription(<code>/sub</code>)",id:"subscriptionsub",level:3},{value:"Description",id:"description",level:4},{value:"Key Parameters",id:"key-parameters",level:4},{value:"Return Value",id:"return-value",level:4},{value:"Notes",id:"notes",level:4},{value:"Unsubscription(<code>/unsub</code>)",id:"unsubscriptionunsub",level:3},{value:"Description",id:"description-1",level:4},{value:"Key Parameters",id:"key-parameters-1",level:4},{value:"Return Value",id:"return-value-1",level:4},{value:"Publishing(<code>/pub</code>)",id:"publishingpub",level:3},{value:"Description",id:"description-2",level:4},{value:"Key Parameters",id:"key-parameters-2",level:4},{value:"Note",id:"note",level:4},{value:"Kill(<code>/kill</code>)",id:"killkill",level:3},{value:"Description",id:"description-3",level:4},{value:"Key Parameters",id:"key-parameters-3",level:4},{value:"Manually Expire Inboxes(/expireinbox)",id:"manually-expire-inboxesexpireinbox",level:3},{value:"Description",id:"description-4",level:4},{value:"Key Parameters",id:"key-parameters-4",level:4},{value:"Note",id:"note-1",level:4}];function a(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"api-service",children:"API Service"})}),"\n",(0,t.jsx)(i.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(i.p,{children:"The API Service plays a vital role in managing devices and ensuring optimal performance. It enables users to perform\nadministrative operations via a set of APIs. These operations include proxy publishing, subscribing, unsubscribing from\nmessages, and device kicking. Additionally, users can use an API to clear unnecessary inbox messages, thereby improving\noverall system performance. In order to maintain the performance of the system when dealing with CleanSession=false, it\nis crucial to clear any offline messages that are no longer in use and lingering in the system."}),"\n",(0,t.jsxs)(i.p,{children:["Swagger yaml can be found ",(0,t.jsx)(i.a,{href:"https://bifromq-api.gz.bcebos.com/BifroMQ-API.yaml",children:"here"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"deployment",children:"Deployment"}),"\n",(0,t.jsx)(i.p,{children:"The API service is seamlessly integrated into the BifroMQ instance. Once BifroMQ is configured and operational, you gain\nimmediate access to its APIs. This means that within the BifroMQ cluster, an API service cluster is automatically\nestablished. The diagram below provides a visual representation of this architecture."}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"API-Arch.png",src:n(88064).A+"",width:"496",height:"342"})}),"\n",(0,t.jsx)(i.p,{children:"One can set up load balancer, e.g. Nginx, in front the API cluster to balance the load."}),"\n",(0,t.jsx)(i.h2,{id:"list-of-apis",children:"List of APIs"}),"\n",(0,t.jsxs)(i.h3,{id:"subscriptionsub",children:["Subscription(",(0,t.jsx)(i.code,{children:"/sub"}),")"]}),"\n",(0,t.jsx)(i.h4,{id:"description",children:"Description"}),"\n",(0,t.jsxs)(i.p,{children:["Users can call ",(0,t.jsx)(i.code,{children:"/sub"})," to do proxy subscription. There are 3 types inboxes in subscription, i.e. cleanSession = true,\ncleanSession = false and external inbox."]}),"\n",(0,t.jsx)(i.p,{children:"Each inbox type behaves slightly differently. The first two inboxes are internal to BifroMQ, while the third is external\nfor customized business purpose."}),"\n",(0,t.jsx)(i.h4,{id:"key-parameters",children:"Key Parameters"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"tenant_id"}),": the tenantId for the user."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"topic_filter"}),": the topicFilter that the user wants to subscribe."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"sub_qos"}),": the subscription QoS for the topicFilter."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"inbox_id"}),": the inbox that the user wants to do proxy subscription."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"subbroker_id"}),": inbox types, i.e. cleanSession = true, cleanSession = false and external ones."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"deliverer_key"}),": the key for message delivery that is mandatory for external inboxes."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Note"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["The value of ",(0,t.jsx)(i.code,{children:"inbox_id"})," depends on whether the session is set to ",(0,t.jsx)(i.code,{children:"cleanSession = true"})," or ",(0,t.jsx)(i.code,{children:"cleanSession = false"}),". In\nthe case of ",(0,t.jsx)(i.code,{children:"cleanSession = true"}),", the ",(0,t.jsx)(i.code,{children:"inbox_id"})," is assigned by BifroMQ, which corresponds to the ",(0,t.jsx)(i.code,{children:"userSessionId"})," in the\n",(0,t.jsx)(i.code,{children:"ClientConnected"})," event. However, for ",(0,t.jsx)(i.code,{children:"cleanSession = false"}),", it is the clientId that is assigned by the users."]}),"\n",(0,t.jsxs)(i.li,{children:["Subscriptions with ",(0,t.jsx)(i.code,{children:"cleanSession = true"})," behavior align with the standard MQTT protocol."]}),"\n",(0,t.jsx)(i.li,{children:"The integration between BifroMQ and external inboxes is a feature that will be introduced in future releases.\nPlease stay tuned for updates."}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"return-value",children:"Return Value"}),"\n",(0,t.jsxs)(i.p,{children:["If subscription successes, it will return requested QoS. In case of failure, the returned QoS will be ",(0,t.jsx)(i.code,{children:"128"}),"."]}),"\n",(0,t.jsx)(i.h4,{id:"notes",children:"Notes"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"For external inboxes, the API service records only the topic filters of interest in BifroMQ. Each external inbox must\nmaintain its list of interesting topicFilters."}),"\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"deliverer_key"})," parameter is mandatory for external inboxes. Inboxes sharing the same ",(0,t.jsx)(i.code,{children:"deliverer_key"})," will use the\nsame RPC channel for message delivery, so users should manage this key carefully."]}),"\n",(0,t.jsx)(i.li,{children:"For cleanSession = false inboxes, they may not be connected to BifroMQ at the moment, so the subscription only deals\nwith recording topicFilters. If there are any retained messages, they will not be pushed. However, for cleanSession =\ntrue inboxes, retained messages will be pushed to corresponding devices."}),"\n"]}),"\n",(0,t.jsxs)(i.h3,{id:"unsubscriptionunsub",children:["Unsubscription(",(0,t.jsx)(i.code,{children:"/unsub"}),")"]}),"\n",(0,t.jsx)(i.h4,{id:"description-1",children:"Description"}),"\n",(0,t.jsxs)(i.p,{children:["The Unsubscription API allows users to unsubscribe from a specific topicFilter. Similar to the subscription process,\nexternal inboxes are responsible for managing their list of interested topicFilters, and users should manage the\n",(0,t.jsx)(i.code,{children:"deliverer_key"})," for external inboxes effectively."]}),"\n",(0,t.jsx)(i.h4,{id:"key-parameters-1",children:"Key Parameters"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"tenant_id"}),": the tenantId for the user."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"topic_filter"}),": the topicFilter that the user wants to unsubscribe."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"inbox_id"}),": the inbox that the user wants to do proxy unsubscription."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"subbroker_id"}),": inbox types, i.e. cleanSession = true, cleanSession = false and external ones."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"deliverer_key"}),": the key for message delivery that is mandatory for external inboxes."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"return-value-1",children:"Return Value"}),"\n",(0,t.jsxs)(i.p,{children:["If unsubscription successes, it will return ",(0,t.jsx)(i.code,{children:"200"})," status code. Otherwise, it will return ",(0,t.jsx)(i.code,{children:"NOT_FOUND"})," for failed\nsubscription or ",(0,t.jsx)(i.code,{children:"FORBIDDEN"})," for topicFilter checking failure."]}),"\n",(0,t.jsxs)(i.h3,{id:"publishingpub",children:["Publishing(",(0,t.jsx)(i.code,{children:"/pub"}),")"]}),"\n",(0,t.jsx)(i.h4,{id:"description-2",children:"Description"}),"\n",(0,t.jsxs)(i.p,{children:["The Publishing API, denoted as ",(0,t.jsx)(i.code,{children:"/pub"}),", allows users to publish a message to a specified topic. It also supports retained\nmessages."]}),"\n",(0,t.jsx)(i.h4,{id:"key-parameters-2",children:"Key Parameters"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"tenant_id"}),": the tenantId for the user."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"topic"}),": the topic of the message."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"client_type"}),": the client type for publisher."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"pub_qos"}),": QoS of the message to be distributed."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"retain"}),": If the message needs to be retained, make it to be true."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"note",children:"Note"}),"\n",(0,t.jsxs)(i.p,{children:["During the publishing phase, a parameter called ",(0,t.jsx)(i.code,{children:"pub_qos"})," is used to denote the publisher's desired Quality of Service\n(QoS). It's important to note that this parameter doesn't dictate the QoS for message delivery between the publisher and\nBifroMQ since the HTTP protocol lacks native QoS support. If the API service were to forcibly downgrade QoS to\n",(0,t.jsx)(i.code,{children:"AT_MOST_ONCE"}),", it could indirectly impact the QoS between BifroMQ and subscribers. Therefore, the API service retains\nthe QoS information. Additionally, it's the responsibility of the user, specifically the publisher, to manage the actual\nQoS between themselves and BifroMQ."]}),"\n",(0,t.jsxs)(i.h3,{id:"killkill",children:["Kill(",(0,t.jsx)(i.code,{children:"/kill"}),")"]}),"\n",(0,t.jsx)(i.h4,{id:"description-3",children:"Description"}),"\n",(0,t.jsx)(i.p,{children:"Sometimes users need to disconnect the other device with the same clientId. Therefore, one can call the API to do the\njob."}),"\n",(0,t.jsx)(i.h4,{id:"key-parameters-3",children:"Key Parameters"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"tenant_id"}),": the tenantId for the user."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"user_id"}),": the user id of the MQTT client connection to be disconnected."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"client_type"}),": the client type for the active kicker."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"manually-expire-inboxesexpireinbox",children:"Manually Expire Inboxes(/expireinbox)"}),"\n",(0,t.jsx)(i.h4,{id:"description-4",children:"Description"}),"\n",(0,t.jsx)(i.p,{children:"This endpoint is used to clean the inbox information stored for connections with cleanSession=false. It includes both\nmetadata and MQTT messages stored in the inbox, actively reducing resource usage for expired connections."}),"\n",(0,t.jsx)(i.h4,{id:"key-parameters-4",children:"Key Parameters"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"tenant_id"}),": the tenantId for the user."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"expiry_seconds"}),": Time limit for expiration. Inboxes that have been inactive for more than this duration will be\ncleaned."]}),"\n"]}),"\n",(0,t.jsx)(i.h4,{id:"note-1",children:"Note"}),"\n",(0,t.jsx)(i.p,{children:"Setting expiry_seconds to 0 will clean all inboxes under the specified tenant, including those still\nonline. Connections will be disconnected due to the loss of metadata. It is crucial to set this parameter appropriately."})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},65404:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>l});var s=n(36672);const t={},r=s.createContext(t);function o(e){const i=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:i},e.children)}},88064:(e,i,n)=>{n.d(i,{A:()=>s});const s=n.p+"assets/images/API-Arch-dc85a6a27094c8bc230d7786cd3f51b8.png"}}]);