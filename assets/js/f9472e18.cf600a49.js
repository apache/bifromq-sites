"use strict";(globalThis.webpackChunkbifromq=globalThis.webpackChunkbifromq||[]).push([[5199],{35756(e,n,r){r.d(n,{R:()=>a,x:()=>l});var s=r(59471);const i={},t=s.createContext(i);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:n},e.children)}},83666(e,n,r){r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"cluster/loadbalance/intro","title":"Load Balancing","description":"BifroMQ applies different load-balancing mechanisms for client-facing services, internal RPC services, and stateful storage services.","source":"@site/docs/cluster/loadbalance/intro.md","sourceDirName":"cluster/loadbalance","slug":"/cluster/loadbalance/intro","permalink":"/docs/cluster/loadbalance/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/docs/cluster/loadbalance/intro.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"intro","sidebar_position":0,"title":"Load Balancing"},"sidebar":"tutorialSidebar","previous":{"title":"Clustering","permalink":"/docs/cluster/clustering"},"next":{"title":"MQTT Server","permalink":"/docs/cluster/loadbalance/mqttserver"}}');var i=r(62615),t=r(35756);const a={id:"intro",sidebar_position:0,title:"Load Balancing"},l="Load Balancing",c={},o=[{value:"Client-Facing Services",id:"client-facing-services",level:2},{value:"Internal RPC Services",id:"internal-rpc-services",level:2},{value:"Stateful Service Clusters",id:"stateful-service-clusters",level:2}];function d(e){const n={br:"br",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"load-balancing",children:"Load Balancing"})}),"\n",(0,i.jsx)(n.p,{children:"BifroMQ applies different load-balancing mechanisms for client-facing services, internal RPC services, and stateful storage services."}),"\n",(0,i.jsx)(n.h2,{id:"client-facing-services",children:"Client-Facing Services"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"}),(0,i.jsx)(n.br,{}),"\n","Distribute external MQTT and API traffic across multiple nodes to improve availability and absorb load variations."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Approach:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use standard ",(0,i.jsx)(n.strong,{children:"Layer 4 or Layer 7 load balancers"})," in front of MQTT Server or API Server."]}),"\n",(0,i.jsxs)(n.li,{children:["In controlled network environments, MQTT clients may use ",(0,i.jsx)(n.strong,{children:"custom client-side balancing strategies"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"internal-rpc-services",children:"Internal RPC Services"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"}),(0,i.jsx)(n.br,{}),"\n","Balance internal request routing for subscription processing, inbox dispatching, and retained-message operations."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Approach:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use BifroMQ\u2019s ",(0,i.jsx)(n.strong,{children:"traffic governance interfaces"})," to inspect service topology, define routing rules, and direct RPC traffic."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"stateful-service-clusters",children:"Stateful Service Clusters"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose:"}),(0,i.jsx)(n.br,{}),"\n","Distribute sharded storage and compute workloads for dynamic subscriptions, offline messages, and retained messages."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Approach:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The storage layer manages ",(0,i.jsx)(n.strong,{children:"shard placement, leader roles, and adaptive load distribution"})," automatically."]}),"\n",(0,i.jsx)(n.li,{children:"Landscape-level APIs provide visibility into shard layout and replica distribution."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);