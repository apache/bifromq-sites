"use strict";(globalThis.webpackChunkbifromq=globalThis.webpackChunkbifromq||[]).push([[8036],{35756(e,r,n){n.d(r,{R:()=>a,x:()=>c});var s=n(59471);const i={},t=s.createContext(i);function a(e){const r=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(t.Provider,{value:r},e.children)}},84456(e,r,n){n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"cluster/loadbalance/rpcserver","title":"Internal RPC Server","description":"BifroMQ\u2019s internal RPC framework supports runtime traffic governing, allowing operators to control how internal service requests are distributed across nodes at runtime.","source":"@site/docs/cluster/loadbalance/rpcserver.md","sourceDirName":"cluster/loadbalance","slug":"/cluster/loadbalance/rpcserver","permalink":"/docs/cluster/loadbalance/rpcserver","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/docs/cluster/loadbalance/rpcserver.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Internal RPC Server"},"sidebar":"tutorialSidebar","previous":{"title":"API Server","permalink":"/docs/cluster/loadbalance/apiserver"},"next":{"title":"Stateful Server Load Balancing","permalink":"/docs/cluster/loadbalance/stateful/intro"}}');var i=n(62615),t=n(35756);const a={sidebar_position:3,title:"Internal RPC Server"},c="Internal RPC Load Balancing",l={},o=[{value:"Traffic governance API",id:"traffic-governance-api",level:2},{value:"Service landscape",id:"service-landscape",level:3},{value:"Request",id:"request",level:5},{value:"Response Structure",id:"response-structure",level:5},{value:"Traffic rules",id:"traffic-rules",level:3},{value:"Get Traffic Rules",id:"get-traffic-rules",level:4},{value:"Request",id:"request-1",level:5},{value:"Response Structure",id:"response-structure-1",level:5},{value:"Set Traffic Rules",id:"set-traffic-rules",level:4},{value:"Request",id:"request-2",level:5},{value:"Unset Traffic Rule",id:"unset-traffic-rule",level:4},{value:"Server Groups",id:"server-groups",level:3},{value:"Set Server Groups (runtime)",id:"set-server-groups-runtime",level:4},{value:"Request",id:"request-3",level:5},{value:"Startup Configuration (static group assignment)",id:"startup-configuration-static-group-assignment",level:4}];function d(e){const r={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"internal-rpc-load-balancing",children:"Internal RPC Load Balancing"})}),"\n",(0,i.jsxs)(r.p,{children:["BifroMQ\u2019s internal RPC framework supports ",(0,i.jsx)(r.strong,{children:"runtime traffic governing"}),", allowing operators to control how internal service requests are distributed across nodes at runtime."]}),"\n",(0,i.jsxs)(r.p,{children:["The following internal RPC services support runtime traffic governance (the value shown is the required ",(0,i.jsx)(r.code,{children:"service_name"})," header):"]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Service"}),(0,i.jsx)(r.th,{children:"Internal role"}),(0,i.jsx)(r.th,{children:(0,i.jsx)(r.code,{children:"<SERVICE_NAME_HEADER>"})})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Dist Server"}),(0,i.jsx)(r.td,{children:"subscription distribution"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"DistService"})})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Inbox Server"}),(0,i.jsx)(r.td,{children:"offline message delivery"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"InboxService"})})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Retain Server"}),(0,i.jsx)(r.td,{children:"retain message lookup"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"RetainService"})})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:"Session Dict Server"}),(0,i.jsx)(r.td,{children:"shared session dictionary"}),(0,i.jsx)(r.td,{children:(0,i.jsx)(r.code,{children:"SessionDictService"})})]})]})]}),"\n",(0,i.jsx)(r.p,{children:"These services form logically independent subclusters on top of the underlay cluster, each responsible for a specific class of internal workloads."}),"\n",(0,i.jsx)(r.h2,{id:"traffic-governance-api",children:"Traffic governance API"}),"\n",(0,i.jsx)(r.p,{children:"The traffic governance API provides introspection and control over routing weights and node groups within a service subcluster."}),"\n",(0,i.jsx)(r.h3,{id:"service-landscape",children:"Service landscape"}),"\n",(0,i.jsx)(r.p,{children:"The Service Landscape API returns all active RPC service instances for a given service_name.\nIt reflects the runtime topology of the service subcluster on the overlay layer, including node identity, bind address, port, static attributes, and dynamically assigned groups."}),"\n",(0,i.jsx)(r.h5,{id:"request",children:"Request"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"GET /service/landscape\nHeaders:\n  service_name: <SERVICE_NAME_HEADER>\n"})}),"\n",(0,i.jsx)(r.h5,{id:"response-structure",children:"Response Structure"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-json",children:'[\n  {\n    "hostId": "OTQ0OWE5NzAtNjliOC00ZDI3LTg5MjQtOWU3NDEyMWNhNDFj", // Identity of the node in the Underlay Cluster\n    "id": "342586ce-a8d4-4d85-9ae0-3bf596e982d5/1456250665", // Identity of the RPC server instance in the Overlay Cluster\n    "address": "10.0.0.2", // RPC server bind address\n    "port": 40469, // RPC server bind port\n    "attributes": {}, // Static metadata configured at startup (e.g., availability zone, rack ID).\n    "groups": [] // Runtime-assigned groups (via `/service/group`)\n  }\n]\n'})}),"\n",(0,i.jsx)(r.h3,{id:"traffic-rules",children:"Traffic rules"}),"\n",(0,i.jsxs)(r.p,{children:["Traffic rules control how tenant-tagged requests are distributed across RPC service instances at runtime.",(0,i.jsx)(r.br,{}),"\n","Rules are evaluated based on the ",(0,i.jsx)(r.code,{children:"service_name"})," header and define a per-tenant routing policy.",(0,i.jsx)(r.br,{}),"\n","Incoming requests from a tenant are distributed across one or more server groups according to their configured weights.",(0,i.jsx)(r.br,{}),"\n","Each server group forwards requests to its RPC servers. If a selected server group has no available servers, the request is rejected.",(0,i.jsx)(r.br,{}),"\n","Tenants without an explicit traffic rule use the default server group."]}),"\n",(0,i.jsx)(r.p,{children:"The traffic rule JSON:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-json",children:'{\n    "<TENANT_ID>": {          // tenant for which the rule applies\n        "<SERVER_GROUP>": <WEIGHT>   // server group name and its routing weight\n    }\n}\n'})}),"\n",(0,i.jsx)(r.h4,{id:"get-traffic-rules",children:"Get Traffic Rules"}),"\n",(0,i.jsx)(r.p,{children:"Returns the current routing rules for the specified service."}),"\n",(0,i.jsx)(r.h5,{id:"request-1",children:"Request"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"GET /service/traffic\nHeaders:\nservice_name: <SERVICE_NAME_HEADER>\n"})}),"\n",(0,i.jsx)(r.h5,{id:"response-structure-1",children:"Response Structure"}),"\n",(0,i.jsx)(r.p,{children:"Same as the traffic rule JSON above."}),"\n",(0,i.jsx)(r.h4,{id:"set-traffic-rules",children:"Set Traffic Rules"}),"\n",(0,i.jsx)(r.p,{children:"Updates traffic rules by merging the provided JSON with the existing rules."}),"\n",(0,i.jsx)(r.h5,{id:"request-2",children:"Request"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"PUT /service/traffic\nHeaders:\nservice_name: <SERVICE_NAME_HEADER>\nBody: traffic rule JSON shown above.\n"})}),"\n",(0,i.jsx)(r.h4,{id:"unset-traffic-rule",children:"Unset Traffic Rule"}),"\n",(0,i.jsxs)(r.p,{children:["Removes traffic rules for the specified tenants.\nThe request body must contain an array of ",(0,i.jsx)(r.code,{children:"<TENANT_ID>"})," values."]}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"DELETE /service/traffic\nHeaders:\nservice_name: <SERVICE_NAME_HEADER>\n"})}),"\n",(0,i.jsx)(r.h3,{id:"server-groups",children:"Server Groups"}),"\n",(0,i.jsx)(r.p,{children:"Service groups classify RPC server instances into logical buckets (e.g., AZ, rack, region).\nTraffic rules reference these groups to determine how tenant traffic is routed.\nA server may belong to multiple groups. Servers with no explicit groups are implicitly part of the 'default' group.\nServer groups can be set in two ways:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"at startup via configuration file (static initial groups)"}),"\n",(0,i.jsx)(r.li,{children:"at runtime via the /service/group API (dynamic override)"}),"\n"]}),"\n",(0,i.jsx)(r.h4,{id:"set-server-groups-runtime",children:"Set Server Groups (runtime)"}),"\n",(0,i.jsx)(r.p,{children:"Assigns one or more group names to a specific RPC server instance."}),"\n",(0,i.jsx)(r.h5,{id:"request-3",children:"Request"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"PUT /service/group\nHeaders:\n  service_name: <SERVICE_NAME_HEADER>\n  server_id: <SERVER_ID>   # Returned from /service/landscape\nBody: JSON array of strings, each represents a group name\n"})}),"\n",(0,i.jsx)(r.p,{children:"Runtime group assignment:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"replaces any previously assigned groups"}),"\n",(0,i.jsx)(r.li,{children:"may assign multiple groups"}),"\n",(0,i.jsx)(r.li,{children:"if the array is empty \u2192 server belongs only to the 'default' group"}),"\n"]}),"\n",(0,i.jsx)(r.h4,{id:"startup-configuration-static-group-assignment",children:"Startup Configuration (static group assignment)"}),"\n",(0,i.jsx)(r.p,{children:"Server groups may also be defined in the configuration file.\nThese groups become the server\u2019s initial group list before any /service/group updates occur."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-yaml",children:'distServiceConfig:\n  server:\n    attributes:\n      - "prod"\n      - "az1"\n'})})]})}function u(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);