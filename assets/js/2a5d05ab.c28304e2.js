"use strict";(self.webpackChunkbifromq=self.webpackChunkbifromq||[]).push([[64559],{65404:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>a});var n=s(36672);const o={},i=n.createContext(o);function r(e){const t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},93737:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"mqtt_best_practices/about_mqtt","title":"About MQTT","description":"Why use MQTT protocol for IoT? What are the advantages compared to HTTP protocol?","source":"@site/versioned_docs/version-3.1.x/98_mqtt_best_practices/2_about_mqtt.md","sourceDirName":"98_mqtt_best_practices","slug":"/mqtt_best_practices/about_mqtt","permalink":"/docs/3.1.x/mqtt_best_practices/about_mqtt","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/versioned_docs/version-3.1.x/98_mqtt_best_practices/2_about_mqtt.md","tags":[],"version":"3.1.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"About MQTT"},"sidebar":"tutorialSidebar","previous":{"title":"Supported Specifications","permalink":"/docs/3.1.x/mqtt_best_practices/mqtt"},"next":{"title":"MQTT Parameter Selection","permalink":"/docs/3.1.x/mqtt_best_practices/mqtt_parameters"}}');var o=s(23420),i=s(65404);const r={sidebar_position:2,title:"About MQTT"},a=void 0,c={},l=[{value:"Why use MQTT protocol for IoT? What are the advantages compared to HTTP protocol?",id:"why-use-mqtt-protocol-for-iot-what-are-the-advantages-compared-to-http-protocol",level:2},{value:"How to deal with abnormal disconnection between the client and the server?",id:"how-to-deal-with-abnormal-disconnection-between-the-client-and-the-server",level:2},{value:"Why are messages lost and the subscribed message recipient did not receive the message sent successfully?",id:"why-are-messages-lost-and-the-subscribed-message-recipient-did-not-receive-the-message-sent-successfully",level:2},{value:"Is the message order received by the subscriber consistent with the sending order?",id:"is-the-message-order-received-by-the-subscriber-consistent-with-the-sending-order",level:2},{value:"Why does the connection-disconnection-reconnection-disconnection situation occur repeatedly?",id:"why-does-the-connection-disconnection-reconnection-disconnection-situation-occur-repeatedly",level:2}];function d(e){const t={h2:"h2",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"why-use-mqtt-protocol-for-iot-what-are-the-advantages-compared-to-http-protocol",children:"Why use MQTT protocol for IoT? What are the advantages compared to HTTP protocol?"}),"\n",(0,o.jsx)(t.p,{children:"IoT devices typically need to send and receive small data packets, such as sensor readings, device status, etc. MQTT (Message Queuing Telemetry Transport) is a lightweight communication protocol based on the publish/subscribe pattern, designed specifically for low-bandwidth and unreliable network environments, making it ideal for IoT applications."}),"\n",(0,o.jsx)(t.p,{children:"Compared to the HTTP protocol, MQTT has the following advantages:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"More lightweight: Compared to the bulky protocol header of HTTP, the MQTT protocol is very streamlined, with a smaller message body than HTTP, which can reduce network transmission burden."}),"\n",(0,o.jsx)(t.li,{children:"Lower power consumption: The low power consumption feature of the MQTT protocol makes it very suitable for IoT devices, such as sensors, smart homes, and other devices, which usually have very limited battery life."}),"\n",(0,o.jsx)(t.li,{children:"More efficient: The MQTT protocol uses a push method to deliver messages, which can greatly reduce communication overhead between clients and servers. At the same time, the QoS mechanism of the MQTT protocol can also ensure the reliable transmission of messages, making communication more stable and efficient."}),"\n",(0,o.jsx)(t.li,{children:"More scalable: The MQTT protocol uses the publish/subscribe pattern of topics, making the system more scalable and able to quickly adapt to new devices and application scenarios. In contrast, the HTTP protocol requires the deployment of RESTful interfaces on the server side, limiting the scalability of the system."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"In summary, the MQTT protocol is suitable for IoT devices that require low power consumption, small data packets, and efficient transmission, while the HTTP protocol is suitable for application scenarios that require a large amount of data transmission and more complex request/response."}),"\n",(0,o.jsx)(t.h2,{id:"how-to-deal-with-abnormal-disconnection-between-the-client-and-the-server",children:"How to deal with abnormal disconnection between the client and the server?"}),"\n",(0,o.jsx)(t.p,{children:"Considering that IoT devices often work in unstable network environments, the MQTT protocol and common open-source client implementations have corresponding designs and processing for unexpected disconnections."}),"\n",(0,o.jsx)(t.p,{children:"Please set up automatic reconnection for the client, and if the client is also responsible for subscribing to topics, you also need to set up automatic re-subscription after reconnection."}),"\n",(0,o.jsx)(t.p,{children:"If you do not want to lose important messages during the disconnection period, you can set the cleanSession setting in the subscription setting to False. However, please use this setting carefully and set the topicfilter reasonably, separating important messages from a large number of ordinary messages, and only using them for the most necessary message subscriptions. A large number of unreasonable use of the cleanSession False setting will bring serious performance pressure and greater message loss risks."}),"\n",(0,o.jsx)(t.p,{children:"If there is an unexpectedly high frequency of disconnections that do not meet expectations, please check the network link from the client to the server."}),"\n",(0,o.jsx)(t.h2,{id:"why-are-messages-lost-and-the-subscribed-message-recipient-did-not-receive-the-message-sent-successfully",children:"Why are messages lost and the subscribed message recipient did not receive the message sent successfully?"}),"\n",(0,o.jsx)(t.p,{children:"There are many possibilities for message loss:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Unstable network causing packet loss: Depending on the specific network environment of the IoT device, different degrees of packet loss may occur. If you need to ensure that the message arrives, you can use the qos 1 setting to send and subscribe to messages. This setting will also consume more performance."}),"\n",(0,o.jsx)(t.li,{children:"Subscriber disconnection: If a topic is not subscribed, the message will be directly discarded."}),"\n",(0,o.jsx)(t.li,{children:"Single connection sending and receiving message exceeds the limit: By default, a single client has a limit of 200 messages per second and 512MB bandwidth. If it is a sender, messages that exceed this limit will fail to send, and if it is a subscriber that exceeds it, messages under the cleanSession True setting will be discarded."}),"\n",(0,o.jsx)(t.li,{children:"The message sending frequency is too high, causing downstream overflow: subscription overflow under cleanSession True, rule engine downstream overflow, inbox message cache overflow under cleanSession False, etc. You can reasonably split the topic to reduce the message frequency received by each subscriber, or use shared subscriptions."}),"\n",(0,o.jsx)(t.li,{children:"Insufficient resources: If the memory or CPU resources deployed by the BifroMQ service are insufficient to support the business scale, this situation may also occur, and the business scale needs to be evaluated and expanded reasonably."}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"is-the-message-order-received-by-the-subscriber-consistent-with-the-sending-order",children:"Is the message order received by the subscriber consistent with the sending order?"}),"\n",(0,o.jsx)(t.p,{children:"According to the MQTT protocol, we guarantee the message order."}),"\n",(0,o.jsx)(t.p,{children:"In particular, under QoS 0, the messages sent by a single sender must arrive in the order they were sent. Under QoS 1, because there is a situation of resending messages, there may be occasional disorder, but after resending messages, according to the protocol, the messages after the resend messages will be sent in order again, ensuring that there is at least one subsequence in the message sequence received by the client that is completely ordered."}),"\n",(0,o.jsx)(t.h2,{id:"why-does-the-connection-disconnection-reconnection-disconnection-situation-occur-repeatedly",children:"Why does the connection-disconnection-reconnection-disconnection situation occur repeatedly?"}),"\n",(0,o.jsx)(t.p,{children:"Generally, it is due to mutual kicking. The ClientID must be unique, otherwise, the conflicting device that has already been connected will be disconnected. If both devices have set up automatic reconnection, then they will kick each other repeatedly, causing this problem."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);