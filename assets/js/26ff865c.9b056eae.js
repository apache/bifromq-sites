"use strict";(self.webpackChunkbifromq=self.webpackChunkbifromq||[]).push([[7146],{65404:(e,i,t)=>{t.d(i,{R:()=>a,x:()=>l});var n=t(36672);const r={},s=n.createContext(r);function a(e){const i=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(s.Provider,{value:i},e.children)}},93742:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"cluster/high_availability","title":"High Availability","description":"BifroMQ is designed to deliver high availability by leveraging a decentralized cluster-building capability provided by its Gossip-based protocol (base-cluster). This architecture eliminates the need for additional service discovery components to establish a cluster, thereby reducing the operational risks associated with single points of failure. The result is a system that can scale flexibly and maintain high availability across all nodes in the cluster.","source":"@site/versioned_docs/version-3.3.x/04_cluster/2_high_availability.md","sourceDirName":"04_cluster","slug":"/cluster/high_availability","permalink":"/docs/3.3.x/cluster/high_availability","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/website/versioned_docs/version-3.3.x/04_cluster/2_high_availability.md","tags":[],"version":"3.3.x","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"High Availability"},"sidebar":"tutorialSidebar","previous":{"title":"Deploy StandardCluster","permalink":"/docs/3.3.x/cluster/standardcluster"},"next":{"title":"Upgrade","permalink":"/docs/3.3.x/cluster/upgrade"}}');var r=t(23420),s=t(65404);const a={sidebar_position:2,title:"High Availability"},l="High Availability",o={},c=[{value:"How to Enable High Availability in a Cluster",id:"how-to-enable-high-availability-in-a-cluster",level:2},{value:"Cluster Node Count",id:"cluster-node-count",level:3},{value:"Clustering Configuration",id:"clustering-configuration",level:3},{value:"Configuration of Replica Count",id:"configuration-of-replica-count",level:3},{value:"Configuration of StoreBalancers",id:"configuration-of-storebalancers",level:3},{value:"Performance Impact",id:"performance-impact",level:2}];function d(e){const i={del:"del",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"high-availability",children:"High Availability"})}),"\n",(0,r.jsx)(i.p,{children:"BifroMQ is designed to deliver high availability by leveraging a decentralized cluster-building capability provided by its Gossip-based protocol (base-cluster). This architecture eliminates the need for additional service discovery components to establish a cluster, thereby reducing the operational risks associated with single points of failure. The result is a system that can scale flexibly and maintain high availability across all nodes in the cluster."}),"\n",(0,r.jsx)(i.p,{children:"Internally, BifroMQ decomposes workloads and organizes them into logically independent subclusters. Each type of load is managed by a separate subcluster, and modules related to storage use the Raft algorithm to ensure consistency and high availability."}),"\n",(0,r.jsx)(i.h2,{id:"how-to-enable-high-availability-in-a-cluster",children:"How to Enable High Availability in a Cluster"}),"\n",(0,r.jsx)(i.p,{children:"The BifroMQ StandardCluster employs a deployment model where all workloads are encapsulated within a single process. Given that different subclusters have varying requirements for high availability, enabling high availability in a BifroMQ cluster requires the following conditions to be met."}),"\n",(0,r.jsx)(i.h3,{id:"cluster-node-count",children:"Cluster Node Count"}),"\n",(0,r.jsxs)(i.p,{children:["For the stateful distributed storage engine, base-kv, within a cluster, service availability is guaranteed only if more than half of the nodes in the cluster are alive. Therefore, ",(0,r.jsx)(i.strong,{children:"the cluster must have a minimum of 3 nodes"})," to ensure high availability."]}),"\n",(0,r.jsx)(i.h3,{id:"clustering-configuration",children:"Clustering Configuration"}),"\n",(0,r.jsx)(i.p,{children:'The configurations related to base-cluster are centralized in the "clusterConfig" section of the configuration file:'}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"Parameter Name"}),(0,r.jsx)(i.th,{children:"Default Value"}),(0,r.jsx)(i.th,{children:"Recommended Value"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"env"}),(0,r.jsx)(i.td,{children:"Test"}),(0,r.jsxs)(i.td,{children:[(0,r.jsx)(i.em,{children:(0,r.jsx)(i.strong,{children:"Prod"})})," or ",(0,r.jsx)(i.em,{children:(0,r.jsx)(i.strong,{children:"Test"})})," to isolate clusters, ensuring nodes from one cluster do not accidentally join another."]})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"host"}),(0,r.jsx)(i.td,{children:"Not Set"}),(0,r.jsx)(i.td,{children:"The IP addresses that must be accessible by all nodes within the cluster."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"port"}),(0,r.jsx)(i.td,{children:"Not Set"}),(0,r.jsx)(i.td,{children:"The ports that are mutually accessible within the cluster."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"clusterDomainName"}),(0,r.jsx)(i.td,{children:"Not Set"}),(0,r.jsx)(i.td,{children:"The domain name registered for cluster nodes."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"seedEndpoints"}),(0,r.jsx)(i.td,{children:"Not Null"}),(0,r.jsx)(i.td,{children:"A list of existing nodes in the cluster."})]})]})]}),"\n",(0,r.jsx)(i.h3,{id:"configuration-of-replica-count",children:"Configuration of Replica Count"}),"\n",(0,r.jsx)(i.p,{children:"BifroMQ leverages base-kv to support three native MQTT load types:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"MQTT Dynamic Subscriptions (DistWorker)"}),"\n",(0,r.jsx)(i.li,{children:"MQTT Offline Messages (InboxStore)"}),"\n",(0,r.jsx)(i.li,{children:"MQTT Retained Messages (RetainStore)"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"The base-kv module uses the Raft protocol to ensure consistency and high availability of shard replicas. To achieve high availability, you must modify the following system variables:"}),"\n",(0,r.jsxs)(i.table,{children:[(0,r.jsx)(i.thead,{children:(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.th,{children:"System Variable Name"}),(0,r.jsx)(i.th,{children:"Default Value"}),(0,r.jsx)(i.th,{children:"Recommended Value"})]})}),(0,r.jsxs)(i.tbody,{children:[(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"dist_worker_range_voter_count"}),(0,r.jsx)(i.td,{children:"3"}),(0,r.jsx)(i.td,{children:"At least 3, preferably an odd number."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"inbox_store_range_voter_count"}),(0,r.jsx)(i.td,{children:"1"}),(0,r.jsx)(i.td,{children:"At least 3, preferably an odd number."})]}),(0,r.jsxs)(i.tr,{children:[(0,r.jsx)(i.td,{children:"retain_store_range_voter_count"}),(0,r.jsx)(i.td,{children:"3"}),(0,r.jsx)(i.td,{children:"At least 3, preferably an odd number."})]})]})]}),"\n",(0,r.jsx)(i.h3,{id:"configuration-of-storebalancers",children:"Configuration of StoreBalancers"}),"\n",(0,r.jsx)(i.p,{children:"BifroMQ's base-kv module implements decentralized management of the persistent service cluster, including capabilities such as initialization, sharding, load balancing, and recovery. The following StoreBalancers are built-in by default:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"RangeBootstrapBalancer"}),": Initializes the cluster (same effect as the ",(0,r.jsx)(i.em,{children:(0,r.jsx)(i.strong,{children:"bootstrap"})})," setting in the config file)."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"RedundantEpochRemovalBalancer"}),": Cleans up redundant ranges."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"RangeLeaderBalancer"}),": Balances the distribution of shard leaders across the cluster."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"ReplicaCntBalancer"}),": Balances the number of shard replicas (both Voter and Learner) across the cluster based on the configured settings."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"RangeSplitBalancer"}),": Splits shards according to predefined load strategies."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"UnreachableReplicaRemovalBalancer"}),": Removes unreachable shard replicas."]}),"\n",(0,r.jsx)(i.li,{children:(0,r.jsxs)(i.del,{children:[(0,r.jsx)(i.strong,{children:"RecoveryBalancer"}),": Deprecated since version 3.3.0 and no longer in use."]})}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"The built-in Balancers are suitable for most use cases. However, for more complex operational scenarios and SLA requirements, users can customize StoreBalancers according to their needs, provided they have a deep understanding of the base-kv architecture. The BifroMQ team also offers professional consulting services in this area."}),"\n",(0,r.jsx)(i.h2,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,r.jsx)(i.p,{children:"Enabling multiple replicas has the following performance impacts by default:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"DistWorker"}),": Optimized for read performance by default, with a maximum of 3 Voter replicas; the remaining replicas are Learners. As the number of nodes increases, subscription routing performance can scale horizontally."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"InboxStore"}),": Configured to balance read and write performance through sharding. Since write performance is significantly affected by the number of Voter replicas, the default configuration uses a single replica. Users can adjust the number of Voter replicas in this setting to enhance availability as needed."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"RetainStore"}),": Optimized for read performance by default, with a maximum of 3 Voter replicas; the remaining replicas are Learners. As the number of nodes increases, retained message matching performance can scale horizontally."]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);