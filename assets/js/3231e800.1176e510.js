"use strict";(globalThis.webpackChunkbifromq=globalThis.webpackChunkbifromq||[]).push([[6719],{35756(e,n,r){r.d(n,{R:()=>l,x:()=>i});var s=r(59471);const a={},t=s.createContext(a);function l(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(t.Provider,{value:n},e.children)}},45199(e,n,r){r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"cluster/loadbalance/stateful/intro","title":"Stateful Server Load Balancing","description":"All stateful services in BifroMQ are built on top of the base-kv distributed storage engine.","source":"@site/docs/cluster/loadbalance/stateful/intro.md","sourceDirName":"cluster/loadbalance/stateful","slug":"/cluster/loadbalance/stateful/intro","permalink":"/docs/cluster/loadbalance/stateful/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/docs/cluster/loadbalance/stateful/intro.md","tags":[],"version":"current","sidebarPosition":0,"frontMatter":{"id":"intro","sidebar_position":0,"title":"Stateful Server Load Balancing"},"sidebar":"tutorialSidebar","previous":{"title":"Internal RPC Server","permalink":"/docs/cluster/loadbalance/rpcserver"},"next":{"title":"Dist Worker","permalink":"/docs/cluster/loadbalance/stateful/distworker"}}');var a=r(62615),t=r(35756);const l={id:"intro",sidebar_position:0,title:"Stateful Server Load Balancing"},i="Stateful Server Load Balancing",c={},d=[{value:"Core Principles",id:"core-principles",level:2},{value:"Replicated Shards and Quorum",id:"replicated-shards-and-quorum",level:3},{value:"Leader-Based Access Model",id:"leader-based-access-model",level:3},{value:"Stateful Services Built on base-kv",id:"stateful-services-built-on-base-kv",level:2},{value:"Store Landscape",id:"store-landscape",level:2},{value:"Get store landscape",id:"get-store-landscape",level:3},{value:"Get range placement in a store",id:"get-range-placement-in-a-store",level:3},{value:"Balancer Framework Overview",id:"balancer-framework-overview",level:2},{value:"Built-in StoreBalancers",id:"built-in-storebalancers",level:3},{value:"BalancerOptions",id:"balanceroptions",level:3},{value:"Enable/Disable Balancer at Runtime",id:"enabledisable-balancer-at-runtime",level:3},{value:"Enable the balancer instances",id:"enable-the-balancer-instances",level:4},{value:"Disable the balancer instances",id:"disable-the-balancer-instances",level:4},{value:"Update Balancer&#39;s rules at runtime",id:"update-balancers-rules-at-runtime",level:3},{value:"Get rules override",id:"get-rules-override",level:4},{value:"Merge rules override with existing rules",id:"merge-rules-override-with-existing-rules",level:4},{value:"Get balancer states",id:"get-balancer-states",level:4}];function o(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"stateful-server-load-balancing",children:"Stateful Server Load Balancing"})}),"\n",(0,a.jsxs)(n.p,{children:["All stateful services in BifroMQ are built on top of the ",(0,a.jsx)(n.strong,{children:"base-kv"})," distributed storage engine.",(0,a.jsx)(n.br,{}),"\n","base-kv provides ",(0,a.jsx)(n.strong,{children:"strong consistency"}),", ",(0,a.jsx)(n.strong,{children:"automatic sharding"}),", and ",(0,a.jsx)(n.strong,{children:"fault tolerance"}),", forming the foundation for high availability and elastic scaling of stateful workloads.\nLoad distribution and availability are jointly managed by ",(0,a.jsx)(n.strong,{children:"replicated shards"})," and the ",(0,a.jsx)(n.strong,{children:"Balancer framework"}),", which continuously adapts the cluster topology to runtime conditions."]}),"\n",(0,a.jsx)(n.h2,{id:"core-principles",children:"Core Principles"}),"\n",(0,a.jsx)(n.h3,{id:"replicated-shards-and-quorum",children:"Replicated Shards and Quorum"}),"\n",(0,a.jsx)(n.p,{children:"Each stateful service cluster continuously replicates its data across multiple nodes using the Raft protocol."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"As long as a quorum of replicas for a shard (Range) remains alive, the service continues to serve reads and writes."}),"\n",(0,a.jsx)(n.li,{children:"Node failures are tolerated transparently without manual intervention."}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"leader-based-access-model",children:"Leader-Based Access Model"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Each shard has a designated ",(0,a.jsx)(n.strong,{children:"leader"})," responsible for handling writes."]}),"\n",(0,a.jsx)(n.li,{children:"Leaders are deliberately distributed across the cluster to avoid hotspots and ensure balanced utilization."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"High availability therefore emerges from:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Replica redundancy"}),"\n",(0,a.jsx)(n.li,{children:"Deterministic leader placement"}),"\n",(0,a.jsx)(n.li,{children:"Continuous topology adjustment"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"stateful-services-built-on-base-kv",children:"Stateful Services Built on base-kv"}),"\n",(0,a.jsx)(n.p,{children:"All BifroMQ stateful servers share the same architectural foundation but optimize their storage schema and access paths based on workload characteristics:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Service"}),(0,a.jsx)(n.th,{children:"store_name (for API headers)"}),(0,a.jsx)(n.th,{children:"Role/Workload"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"/docs/cluster/loadbalance/stateful/distworker",children:(0,a.jsx)(n.strong,{children:"DistWorker"})})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"dist.worker"})}),(0,a.jsx)(n.td,{children:"subscription routing"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"/docs/cluster/loadbalance/stateful/inboxstore",children:(0,a.jsx)(n.strong,{children:"InboxStore"})})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"inbox.store"})}),(0,a.jsx)(n.td,{children:"persistent offline message queues"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.a,{href:"/docs/cluster/loadbalance/stateful/retainstore",children:(0,a.jsx)(n.strong,{children:"RetainStore"})})}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"retain.store"})}),(0,a.jsx)(n.td,{children:"retained message storage"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:"This design allows each service to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use the same base-kv primitives"}),"\n",(0,a.jsxs)(n.li,{children:["Apply ",(0,a.jsx)(n.strong,{children:"deep, workload-specific optimizations"})]}),"\n",(0,a.jsx)(n.li,{children:"Reuse the same balancing and recovery mechanisms"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"store-landscape",children:"Store Landscape"}),"\n",(0,a.jsx)(n.p,{children:"Stateful services run on an overlay cluster just like RPC services. You can inspect the server topology via API and also inspect how Range replicas are placed across storage nodes."}),"\n",(0,a.jsx)(n.h3,{id:"get-store-landscape",children:"Get store landscape"}),"\n",(0,a.jsx)(n.p,{children:"List the nodes of the stateful service overlay cluster."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Request"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"GET /store/landscape\nHeaders:\n  store_name: <STORE_NAME_HEADER>\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Response"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "hostId": "c3RvcmUtaWQ=", // Identity of the node in the Underlay Cluster\n    "id": "710dc192-4641-4b31-bde1-a36329b33273", // Identity of the stateful server instance in the Overlay Cluster\n    "address": "10.0.0.2", // server bind address\n    "port": 36801, // server bind port\n    "attributes": {\n        ...\n    }\n  }\n]\n'})}),"\n",(0,a.jsx)(n.h3,{id:"get-range-placement-in-a-store",children:"Get range placement in a store"}),"\n",(0,a.jsx)(n.p,{children:"List Range replicas hosted on a specific store server."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Request"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"GET /store/ranges\nHeaders:\n  store_name: <STORE_NAME_HEADER>\n  store_id: <STORE_ID_HEADER>\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Response"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'[\n  {\n    "id": "115240914861228032_0", // the range id\n    "ver": 14, // the version of range\n    "boundary": {\n      // the range boundary\n      "startKey": null,\n      "endKey": null\n    },\n    "state": "Normal", // the range state\n    "role": "Leader", // the replica role\n    "clusterConfig": {\n      "voters": [\n        "710dc192-4641-4b31-bde1-a36329b33273",\n        "c2784a36-4509-41be-96bc-5809026bce99",\n        "cd360c5f-7693-40c6-af9c-541cc2467a00"\n      ],\n      "learners": [],\n      "nextVoters": [],\n      "nextLearners": []\n    }\n  }\n]\n'})}),"\n",(0,a.jsx)(n.h2,{id:"balancer-framework-overview",children:"Balancer Framework Overview"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.strong,{children:"Balancer framework"})," continuously shapes the base-kv cluster topology. Although a centralized coordinator is straightforward to implement, the framework is designed to enable ",(0,a.jsx)(n.strong,{children:"distributed convergence"}),", meaning there is:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"No central coordinator"}),"\n",(0,a.jsx)(n.li,{children:"No single point of control"}),"\n",(0,a.jsx)(n.li,{children:"No out-of-band orchestration"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Achieving distributed convergence requires each balancer implementation to be deterministic:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Every node observes the strong eventually consistent global cluster state"}),"\n",(0,a.jsxs)(n.li,{children:["Each balancer deterministically derives the same ",(0,a.jsx)(n.em,{children:"expected"})," Range topology (the built-in balancers follow this pattern)"]}),"\n",(0,a.jsx)(n.li,{children:"Each node independently executes balance commands for the Ranges it currently leads"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"built-in-storebalancers",children:"Built-in StoreBalancers"}),"\n",(0,a.jsxs)(n.p,{children:["BifroMQ ships with several built-in Balancers that cover common scenarios and can serve as references for custom implementations.",(0,a.jsx)(n.br,{}),"\n","The framework lets Balancer implementations expose runtime-tunable rules and be started/paused via API; which balancers to enable and their initial rules are set in configuration (for example, ",(0,a.jsx)(n.code,{children:"BalancerOptions.balancers"})," keyed by balancerFactory FQN)."]}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Balancer"}),(0,a.jsx)(n.th,{children:"Focus"}),(0,a.jsx)(n.th,{children:"Rules"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"RangeLeaderBalancer"})}),(0,a.jsx)(n.td,{children:"Evenly spread Range leaders to avoid hotspots"}),(0,a.jsx)(n.td,{})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"ReplicaCntBalancer"})}),(0,a.jsx)(n.td,{children:"Keep replica counts aligned with goals (voters/learners)"}),(0,a.jsxs)(n.td,{children:["- ",(0,a.jsx)(n.code,{children:"votersPerRange"}),": target voters per range (must be odd)",(0,a.jsx)("br",{}),"- ",(0,a.jsx)(n.code,{children:"learnersPerRange"}),": target learners per range (-1 means no limit)"]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"RangeSplitBalancer"})}),(0,a.jsx)(n.td,{children:'Split "hot" Ranges to sustain throughput'}),(0,a.jsxs)(n.td,{children:["- ",(0,a.jsx)(n.code,{children:"maxCpuUsagePerRange"}),": CPU threshold",(0,a.jsx)("br",{}),"- ",(0,a.jsx)(n.code,{children:"maxIODensityPerRange"}),": IO density cap",(0,a.jsx)("br",{}),"- ",(0,a.jsx)(n.code,{children:"ioNanosLimitPerRange"}),": IO latency cap (ns)",(0,a.jsx)("br",{}),"- ",(0,a.jsx)(n.code,{children:"maxRangesPerStore"}),": per-store range cap"]})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"balanceroptions",children:"BalancerOptions"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"/docs/admin_guide/configuration/config_file_manual#balanceroptions",children:(0,a.jsx)(n.code,{children:"BalancerOptions"})})," tells a BifroMQ process with DistWorker enabled which balancers to instantiate at startup and the initial values of their rules. ",(0,a.jsx)(n.code,{children:"BalancerOptions.balancers"})," is a map keyed by the balancerFactory FQN, with a ",(0,a.jsx)(n.code,{children:"Struct"})," payload for initial rules. For example, to start a ",(0,a.jsx)(n.code,{children:"ReplicaCntBalancer"})," on DistWorker with default replica targets:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"distWorkerConfig:\n  balanceConfig:\n    balancers:\n      org.apache.bifromq.dist.worker.balance.ReplicaCntBalancerFactory:\n        votersPerRange: 3\n        learnersPerRange: -1\n"})}),"\n",(0,a.jsx)(n.h3,{id:"enabledisable-balancer-at-runtime",children:"Enable/Disable Balancer at Runtime"}),"\n",(0,a.jsxs)(n.p,{children:["Balancers can be started or paused via the runtime API without restarting the service. This lets operators temporarily disable a balancer for observation or mitigation, then re-enable it as needed; deterministic behavior preserves convergence when reactivated. Note: ensure the ",(0,a.jsx)(n.code,{children:"balancer_factory_class"})," is correct when enabling the balancer instances initialized via ",(0,a.jsx)(n.code,{children:"BalancerOptions"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"enable-the-balancer-instances",children:"Enable the balancer instances"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"PUT /store/balancer/enable\nHeaders:\n  store_name: <STORE_NAME_HEADER>\n  balancer_factory_class: <BALANCER_FACTORY_CLASS_FQN>\n"})}),"\n",(0,a.jsx)(n.h4,{id:"disable-the-balancer-instances",children:"Disable the balancer instances"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"PUT /store/balancer/disable\nHeaders:\n  store_name: <STORE_NAME_HEADER>\n  balancer_factory_class: <BALANCER_FACTORY_CLASS_FQN>\n"})}),"\n",(0,a.jsx)(n.h3,{id:"update-balancers-rules-at-runtime",children:"Update Balancer's rules at runtime"}),"\n",(0,a.jsxs)(n.p,{children:["Balancer rules (the same ",(0,a.jsx)(n.code,{children:"Struct"})," schema used in ",(0,a.jsx)(n.code,{children:"BalancerOptions.balancers"}),") can be updated at runtime through the API. New rules take effect immediately, and subsequent balance cycles converge using the updated values."]}),"\n",(0,a.jsx)(n.h4,{id:"get-rules-override",children:"Get rules override"}),"\n",(0,a.jsx)(n.p,{children:"Retrieve the rules override; a 404 is returned if no override is set."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Request"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"GET /store/balancer/rules\nHeaders:\n  store_name: <STORE_NAME_HEADER>\n  balancer_factory_class: <BALANCER_FACTORY_CLASS_FQN>\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Response"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "votersPerRange": 1.0\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"merge-rules-override-with-existing-rules",children:"Merge rules override with existing rules"}),"\n",(0,a.jsx)(n.p,{children:"Merge a rules override with existing rules; the caller must ensure the payload is structurally valid."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"PUT /store/balancer/rules\nHeaders:\n  store_name: <STORE_NAME_HEADER>\n  balancer_factory_class: <BALANCER_FACTORY_CLASS_FQN>\nBody: balance rules override json\n"})}),"\n",(0,a.jsx)(n.h4,{id:"get-balancer-states",children:"Get balancer states"}),"\n",(0,a.jsx)(n.p,{children:"Get the latest state of the balancer instances running on each stateful server."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Request"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"GET /store/balancer\nHeaders:\n  store_name: <STORE_NAME_HEADER>\n  balancer_factory_class: <BALANCER_FACTORY_CLASS_FQN>\n"})}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Response"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "org.apache.bifromq.dist.worker.balance.ReplicaCntBalancerFactory": {\n    "710dc192-4641-4b31-bde1-a36329b33273": { // store id running the balancer instance\n      "disable": false, // whether the balancer is disabled\n      "loadRules": { // effective load rules\n        "votersPerRange": 1.0,\n        "learnersPerRange": -1.0\n      },\n      "hlc": "115526170745044992" // hlc timestamp of last update\n    },\n    ...\n  }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);