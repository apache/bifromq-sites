"use strict";(self.webpackChunkbifromq=self.webpackChunkbifromq||[]).push([[31868],{53546:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(59729);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},59973:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"plugin/resource_throttler","title":"Resource Throttler","description":"In BifroMQ\'s multi-tenant architecture, tenants share resources provided by a single cluster instance. To prevent any single tenant from overusing resources and impacting others, it is crucial to control each tenant\'s resource usage","source":"@site/versioned_docs/version-3.3.x/06_plugin/3_resource_throttler.md","sourceDirName":"06_plugin","slug":"/plugin/resource_throttler","permalink":"/docs/3.3.x/plugin/resource_throttler","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/versioned_docs/version-3.3.x/06_plugin/3_resource_throttler.md","tags":[],"version":"3.3.x","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Resource Throttler"},"sidebar":"tutorialSidebar","previous":{"title":"Event Collector","permalink":"/docs/3.3.x/plugin/event_collector"},"next":{"title":"Setting Provider","permalink":"/docs/3.3.x/plugin/setting_provider/intro"}}');var r=t(65813),i=t(53546);const o={sidebar_position:4,title:"Resource Throttler"},c=void 0,d={},l=[{value:"Interface Method",id:"interface-method",level:2},{value:"Metrics",id:"metrics",level:2},{value:"Implementation Considerations",id:"implementation-considerations",level:2},{value:"Example Implementation",id:"example-implementation",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"In BifroMQ's multi-tenant architecture, tenants share resources provided by a single cluster instance. To prevent any single tenant from overusing resources and impacting others, it is crucial to control each tenant's resource usage\nglobally at runtime. It is important to note that the ability to achieve load isolation among tenants through resource limitations presupposes the availability of surplus resources in the cluster during peak business periods."}),"\n",(0,r.jsxs)(n.p,{children:["Tenant-level global resource limitations require real-time monitoring of each tenant's cluster resource usage. BifroMQ provides ",(0,r.jsx)(n.a,{href:"/docs/3.3.x/admin_guide/observability/metrics/tenantmetrics",children:"Tenant-level Metrics"})," for measuring resources in\nterms of quantity and rate, including Gauge, Counter, and Summary metrics."]}),"\n",(0,r.jsx)(n.p,{children:"The interface for the plugin is defined in the following Maven module:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:"\n<dependency>\n    <groupId>com.baidu.bifromq</groupId>\n    <artifactId>bifromq-plugin-resource-throttler</artifactId>\n    <version>X.Y.Z</version> \x3c!--replace X.Y.Z with the latest version number--\x3e\n</dependency>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["BifroMQ allows only one instance of the Resource Throttler to run at a time. The specific implementation class to be loaded must be specified in the ",(0,r.jsx)(n.a,{href:"/docs/3.3.x/admin_guide/configuration/config_file_manual",children:"configuration file"})," by its\nFully Qualified Name (FQN):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'resourceThrottlerFQN: "YOUR_SETTING_PROVIDER_CLASS"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"interface-method",children:"Interface Method"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"public boolean hasResource(String tenantId, TenantResourceType type);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This method is called synchronously on BifroMQ's worker thread and must be implemented efficiently to avoid impacting BifroMQ performance. A return value of false triggers a limiting action, and a ResourceThrottling event is generated and\nreported to the ",(0,r.jsx)(n.a,{href:"/docs/3.3.x/plugin/event_collector",children:"Event Collector"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Here are the resource types defined in ",(0,r.jsx)(n.code,{children:"TenantResourceType"}),":"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Enum Value"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Action on Limiting(MQTT3)"}),(0,r.jsx)(n.th,{children:"Action on Limiting(MQTT5)"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalConnections"})}),(0,r.jsx)(n.td,{children:"Total number of connections"}),(0,r.jsx)(n.td,{children:"ConnAck with code(0x03)"}),(0,r.jsx)(n.td,{children:"ConnAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalSessionMemoryBytes"})}),(0,r.jsx)(n.td,{children:"Total session memory usage in bytes"}),(0,r.jsx)(n.td,{children:"ConnAck with code(0x03)"}),(0,r.jsx)(n.td,{children:"ConnAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalPersistentSessions"})}),(0,r.jsx)(n.td,{children:"Total number of persistent sessions"}),(0,r.jsx)(n.td,{children:"Close connection by server"}),(0,r.jsx)(n.td,{children:"Disconnect with code(0x97) and close connection by server"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalPersistentSessionSpaceBytes"})}),(0,r.jsx)(n.td,{children:"Total persistent session storage space in bytes"}),(0,r.jsx)(n.td,{children:"Close connection by server"}),(0,r.jsx)(n.td,{children:"Disconnect with code(0x97) and close connection by server"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalSharedSubscriptions"})}),(0,r.jsx)(n.td,{children:"Total number of shared subscriptions"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x80)"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalTransientSubscriptions"})}),(0,r.jsx)(n.td,{children:"Total number of transient subscriptions"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x80)"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalPersistentSubscriptions"})}),(0,r.jsx)(n.td,{children:"Total number of persistent subscriptions"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x80)"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalRetainMessageSpaceBytes"})}),(0,r.jsx)(n.td,{children:"Total storage space for Retain messages in bytes"}),(0,r.jsx)(n.td,{children:"Ignore"}),(0,r.jsx)(n.td,{children:"Ignore"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalRetainTopics"})}),(0,r.jsx)(n.td,{children:"Total number of Retain topics"}),(0,r.jsx)(n.td,{children:"Ignore"}),(0,r.jsx)(n.td,{children:"Ignore"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalConnectPerSecond"})}),(0,r.jsx)(n.td,{children:"Total connections per second"}),(0,r.jsx)(n.td,{children:"ConnAck with code(0x03)"}),(0,r.jsx)(n.td,{children:"ConnAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalInboundBytesPerSecond"})}),(0,r.jsx)(n.td,{children:"Total inbound bytes per second"}),(0,r.jsx)(n.td,{children:"Slowdown throughput"}),(0,r.jsx)(n.td,{children:"Slowdown throughput"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalTransientSubscribePerSecond"})}),(0,r.jsx)(n.td,{children:"Total transient subscribes per second"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x80)"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalPersistentSubscribePerSecond"})}),(0,r.jsx)(n.td,{children:"Total persistent subscribes per second"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x80)"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalTransientUnsubscribePerSecond"})}),(0,r.jsx)(n.td,{children:"Total transient unsubscribes per second"}),(0,r.jsx)(n.td,{children:"UnsubAck only"}),(0,r.jsx)(n.td,{children:"UnsubAck with code(0x80)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalPersistentUnsubscribePerSecond"})}),(0,r.jsx)(n.td,{children:"Total persistent unsubscribes per second"}),(0,r.jsx)(n.td,{children:"UnsubAck only"}),(0,r.jsx)(n.td,{children:"UnsubAck with code(0x80)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalTransientFanOutBytesPerSeconds"})}),(0,r.jsx)(n.td,{children:"Total transient fan-out bytes per second"}),(0,r.jsx)(n.td,{children:"Throttled to one subscriber"}),(0,r.jsx)(n.td,{children:"Throttled"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalPersistentFanOutBytesPerSeconds"})}),(0,r.jsx)(n.td,{children:"Total persistent fan-out bytes per second"}),(0,r.jsx)(n.td,{children:"Throttled to one subscriber"}),(0,r.jsx)(n.td,{children:"Throttled"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalRetainedMessagesPerSeconds"})}),(0,r.jsx)(n.td,{children:"Total Retain messages per second"}),(0,r.jsx)(n.td,{children:"Ignore"}),(0,r.jsx)(n.td,{children:"Ignore"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalRetainedBytesPerSecond"})}),(0,r.jsx)(n.td,{children:"Total bytes for Retain messages per second"}),(0,r.jsx)(n.td,{children:"Ignore"}),(0,r.jsx)(n.td,{children:"Ignore"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalRetainMatchPerSeconds"})}),(0,r.jsx)(n.td,{children:"Total Retain message match requests per second"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x80)"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x97)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"TotalRetainMatchBytesPerSecond"})}),(0,r.jsx)(n.td,{children:"Total bytes for Retain match requests per second"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x80)"}),(0,r.jsx)(n.td,{children:"SubAck with code(0x97)"})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"These enum values represent the types of resources that can be throttled in a multi-tenant BifroMQ setup, with different resource types triggering different limiting actions."}),"\n",(0,r.jsx)(n.h2,{id:"metrics",children:"Metrics"}),"\n",(0,r.jsxs)(n.p,{children:["Because the ",(0,r.jsx)(n.code,{children:"hasResource"})," method is frequently called, BifroMQ records and outputs the following metrics to help\nplugin implementers observe the performance indicators of the plugin interface methods:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Metric Name"}),(0,r.jsx)(n.th,{children:"Meter Type"}),(0,r.jsxs)(n.th,{children:["Tag(",(0,r.jsx)(n.code,{children:"method"}),")"]}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"call.exec.timer"})}),(0,r.jsx)(n.td,{children:"TIMER"}),(0,r.jsx)(n.td,{children:"ResourceThrottler/hasResource"}),(0,r.jsxs)(n.td,{children:["Latency for ",(0,r.jsx)(n.code,{children:"hasResource"})," call"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"call.exec.fail.count"})}),(0,r.jsx)(n.td,{children:"COUNTER"}),(0,r.jsx)(n.td,{children:"ResourceThrottler/hasResource"}),(0,r.jsxs)(n.td,{children:["Fail counter for ",(0,r.jsx)(n.code,{children:"hasResource"})," call"]})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"implementation-considerations",children:"Implementation Considerations"}),"\n",(0,r.jsx)(n.p,{children:"Implementing multi-tenant services with BifroMQ involves several key considerations for effectively managing resource usage and ensuring fair access across tenants:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Collection and Aggregation of Tenant Metrics"}),": Collect resource metrics from BifroMQ for each tenant to build and maintain a real-time view of resource usage. The real-time nature of this view determines the precision of throttling\nstrategies."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Resource Limitation Strategy"}),": Based on the real-time resource view, implement decision-making for tenant resource allocation and translate these into specific resource limitation instructions."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Implementing Resource Limitations"}),": Resource limitation instructions need to be fed back to BifroMQ through the ",(0,r.jsx)(n.code,{children:"hasResource"})," method in a non-blocking manner."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["BifroMQ includes an example implementation of the Resource Throttler, which can be enabled by specifying ",(0,r.jsx)(n.code,{children:"resourceThrottlerFQN"})," as ",(0,r.jsx)(n.code,{children:"com.baidu.demo.plugin.DemoResourceThrottler"})," in\nthe ",(0,r.jsx)(n.a,{href:"/docs/3.3.x/admin_guide/configuration/intro",children:"configuration file"}),". The example uses a JVM startup argument (",(0,r.jsx)(n.code,{children:"-Dplugin.resourcethrottler.url"}),") to specify a callback URL for a webhook."]}),"\n",(0,r.jsx)(n.p,{children:"When BifroMQ calls the hasResource method, the plugin initiates a GET request that includes tenant_id and resource_type headers, corresponding to the two parameters of the hasResource method call. The request is asynchronous, and\nhasResource always returns true before a response is received, ensuring processing is not blocked by the request."}),"\n",(0,r.jsx)(n.p,{children:"The result of the request is cached for 60 seconds and refreshed every second. The response body's string is parsed into a boolean value, which becomes the return value of the hasResource method."}),"\n",(0,r.jsxs)(n.p,{children:["Below is a demonstration webhook server implementation (based on Node.js) that can be used to test the example plugin. The webhook URL address is ",(0,r.jsx)(n.code,{children:"http://<ADDR>:<PORT>/query"}),". Two additional urls ",(0,r.jsx)(n.code,{children:"http://<ADDR>:<PORT>/throttle"}),",\nand ",(0,r.jsx)(n.code,{children:"http://<ADDR>:<PORT>/release"})," are for setting and cancelling the throttling state for a given tenant, respectively."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const hasResourceMap = {};\n\nconst args = process.argv.slice(2);\nconst hostname = args[0] || 'localhost'; \nconst port = args[1] || 3000; \n\nconst server = http.createServer((req, res) => {\n\nconst parsedUrl = url.parse(req.url, true); \nconst pathname = parsedUrl.pathname;\n\nres.setHeader('Content-Type', 'text/plain');\n\nif (pathname === '/query') {\n    const tenantId = req.headers['tenant_id'];\n    const resourceType = req.headers['resource_type'];\n    const key = `${tenantId}${resourceType}`;\n\n    const exists = key in hasResourceMap ? hasResourceMap[key] : true;\n    res.end(`${exists}`);\n\n}\nelse if (pathname === '/throttle') {\n    const tenantId = req.headers['tenant_id'];\n    the resourceType = req.headers['resource_type'];\n    const key = `${tenantId}${resourceType}`;\n\n    hasResourceMap[key] = false;\n    res.end('Throttled');\n\n}\nelse if (pathname === '/release') {\n    the tenantId = req.headers['tenant_id'];\n    the resourceType = req.headers['resource_type'];\n    const key = `${tenantId}${resourceType}`;\n\n    delete hasResourceMap[key];\n    res.end('Released');\n}\nelse {\n    res.statusCode = 404;\n    res.end('Not Found');\n}\n});\n\nserver.listen(port, hostname, () => {\n    console.log(`Server listening on port ${server.address().port} from address ${server.address().address}`);\n});\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}}}]);