"use strict";(globalThis.webpackChunkbifromq=globalThis.webpackChunkbifromq||[]).push([[8148],{93152(e,t,n){n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>c,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"plugin/event_collector","title":"Event Collector","description":"The Event Collector plugin is designed to capture a variety of events that occur during the running of BifroMQ. The interface for this plugin is defined in the following Maven module:","source":"@site/docs/plugin/event_collector.mdx","sourceDirName":"plugin","slug":"/plugin/event_collector","permalink":"/docs/plugin/event_collector","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/bifromq-sites/tree/master/docs/plugin/event_collector.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Event Collector"},"sidebar":"tutorialSidebar","previous":{"title":"Client Balancer","permalink":"/docs/plugin/client_balancer"},"next":{"title":"Resource Throttler","permalink":"/docs/plugin/resource_throttler"}}');var r=n(62615),o=n(35756),l=n(43088),s=n(58992);const c={sidebar_position:3,title:"Event Collector"},a=void 0,d={},h=[{value:"Event Types",id:"event-types",level:2},{value:"Interface Method",id:"interface-method",level:2},{value:"Metrics",id:"metrics",level:2}];function p(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"The Event Collector plugin is designed to capture a variety of events that occur during the running of BifroMQ. The interface for this plugin is defined in the following Maven module:"}),"\n",(0,r.jsx)(l.A,{language:"xml",children:`<dependency>\n  <groupId>org.apache.bifromq</groupId>\n  <artifactId>bifromq-plugin-event-collector</artifactId>\n  <version>${(0,s.r)().label}</version>\n</dependency>`}),"\n",(0,r.jsx)(t.p,{children:"Upon startup, BifroMQ scans the plugins directory and loads all available EventCollector implementations. It is recommended that each EventCollector focuses only on a simple specific task by utilizing the EventType feature to filter out\nevents that are not relevant to their intended purpose."}),"\n",(0,r.jsx)(t.h2,{id:"event-types",children:"Event Types"}),"\n",(0,r.jsxs)(t.p,{children:["The types of event objects generated during BifroMQ's runtime all inherit from\nthe ",(0,r.jsx)(t.a,{href:"https://github.com/apache/bifromq/blob/main/bifromq-plugin/bifromq-plugin-event-collector/src/main/java/org/apache/bifromq/plugin/eventcollector/Event.java",children:"Event"})," class. Each specific event class corresponds to\nan ",(0,r.jsx)(t.a,{href:"https://github.com/apache/bifromq/blob/main/bifromq-plugin/bifromq-plugin-event-collector/src/main/java/org/apache/bifromq/plugin/eventcollector/EventType.java",children:"EventType"})," enumeration, which can be accessed through the type() method\non the object. This facilitates the implementation of event filtering logic. The hlc() method allows for retrieving an event object's timestamp. BifroMQ's timestamps are partially ordered, reflecting the sequence in which related events\noccur. This feature is particularly useful for handling events in BifroMQ's distributed deployments."]}),"\n",(0,r.jsx)(t.h2,{id:"interface-method",children:"Interface Method"}),"\n",(0,r.jsxs)(t.p,{children:["When an event is generated, BifroMQ invokes the ",(0,r.jsx)(t.code,{children:"report()"})," method on all loaded EventCollectors. The method signature is as follows:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:"public void report(Event<?> event);\n"})}),"\n",(0,r.jsx)(t.p,{children:"This method is called on BifroMQ's worker thread. As the load increases, a large number of events will be generated. To avoid the creation of a multitude of event objects and excessive memory overhead, the event object passed into this\nmethod will be reused after the method returns. Therefore, when implementing the Event Collector plugin, it's important to consider the following:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Avoid including complex business logic within the report method to ensure it returns quickly; otherwise, it may negatively impact BifroMQ's performance."}),"\n",(0,r.jsxs)(t.li,{children:["The ownership of the passed-in event object does not transfer. If the business logic is asynchronous and there's a need to access the content of the event after the report method returns, you should create a shallow copy of the object\nusing the ",(0,r.jsx)(t.code,{children:"clone()"})," method before returning."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"metrics",children:"Metrics"}),"\n",(0,r.jsxs)(t.p,{children:["Because the ",(0,r.jsx)(t.code,{children:"report"})," method is frequently called, BifroMQ records and outputs the following metrics to help\nplugin implementers observe the performance indicators of the plugin interface methods:"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Metric Name"}),(0,r.jsx)(t.th,{children:"Meter Type"}),(0,r.jsxs)(t.th,{children:["Tag(",(0,r.jsx)(t.code,{children:"method"}),")"]}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsx)(t.tbody,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"call.exec.timer"})}),(0,r.jsx)(t.td,{children:"TIMER"}),(0,r.jsx)(t.td,{children:"EventCollector/report"}),(0,r.jsxs)(t.td,{children:["Latency for ",(0,r.jsx)(t.code,{children:"report"})," call"]})]})})]})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);