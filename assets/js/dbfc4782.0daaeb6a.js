"use strict";(self.webpackChunkbifromq=self.webpackChunkbifromq||[]).push([[38749],{91895:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"bifromq-version-3","metadata":{"permalink":"/blog/bifromq-version-3","editUrl":"https://github.com/apache/bifromq-sites/tree/master/blog","source":"@site/blog/2024-03-14-bifromq-3.0.0.mdx","title":"BifroMQ 3.0.0 Beta: Enhanced Messaging with MQTT 5.0","description":"We\'re excited to unveil the beta release of BifroMQ 3.0.0, a milestone that signifies major progress in the BifroMQ project. This latest version introduces an array of new","date":"2024-03-14T00:00:00.000Z","tags":[{"inline":true,"label":"BifroMQ","permalink":"/blog/tags/bifro-mq"},{"inline":true,"label":"MQTT","permalink":"/blog/tags/mqtt"},{"inline":true,"label":"Topic","permalink":"/blog/tags/topic"},{"inline":true,"label":"TopicFilter","permalink":"/blog/tags/topic-filter"},{"inline":true,"label":"Subscription","permalink":"/blog/tags/subscription"},{"inline":true,"label":"Serverless","permalink":"/blog/tags/serverless"},{"inline":true,"label":"Multi-Tenant","permalink":"/blog/tags/multi-tenant"}],"readingTime":1.49,"hasTruncateMarker":true,"authors":[{"name":"Yonny(Yu) Hao","url":"https://github.com/popduke","imageURL":"https://github.com/popduke.png","key":"HaoYu","page":null}],"frontMatter":{"slug":"bifromq-version-3","title":"BifroMQ 3.0.0 Beta: Enhanced Messaging with MQTT 5.0","authors":["HaoYu"],"tags":["BifroMQ","MQTT","Topic","TopicFilter","Subscription","Serverless","Multi-Tenant"]},"unlisted":false,"nextItem":{"title":"BifroMQ\'s Topic Subscription Mechanism","permalink":"/blog/bifromq-topic-subscription"}},"content":"We\'re excited to unveil the beta [release](https://github.com/bifromqio/bifromq/releases/tag/v3.0.0-beta.1) of BifroMQ 3.0.0, a milestone that signifies major progress in the BifroMQ project. This latest version introduces an array of new\\nfeatures aimed at enhancing the messaging experience, with full adoption of the MQTT 5.0 standard. It\'s important to note that BifroMQ 3.0.0 introduces groundbreaking changes, making it incompatible with data from previous versions. The\\nplugin interface has also been upgraded to support MQTT 5.0 functionalities, which means it cannot support direct rolling upgrades from older versions.\\n\\n\x3c!--truncate--\x3e\\n\\n**Key Features of BifroMQ 3.0.0:**\\n\\n- **Full Support for MQTT 5.0:** Explore the new capabilities of MQTT 5, including SharedSubscription, TopicAlias, SubscriptionIdentifier, FlowControl, EnhancedAuthentication, SessionExpiry, WillDelay, and more, designed to meet all your\\n  messaging needs.\\n\\n- **Enhanced Observability of Tenant Loads:** The latest version offers improved observability into tenant loads via [Tenant Metrics](/docs/admin_guide/observability/metrics/intro/), providing timely and accurate insights into each tenant\'s\\n  resource usage.\\n\\n- **Tenant-Level Real-Time Resource Limitation:** A new plugin type, the [Resource Throttler](/docs/plugin/resource_throttler/), has been introduced to facilitate tenant-level resource limitation. This feature simplifies the implementation\\n  of resource and load isolation in multi-tenant systems.\\n\\n- **Improved API Usability:** Significant enhancements have been made to [API usability](/docs/user_guide/api/intro/), making it easier for users to interact with BifroMQ.\\n\\n- **Backpressure Protection:** This feature aims to ensure system stability and reliability by protecting against overload.\\n\\nIn addition to functional upgrades, the official [documentation](/docs/get_started/intro/) has been comprehensively updated for clarity and depth.\\n\\nWe encourage you to download, test, and provide feedback on this beta version of BifroMQ 3.0.0. Your insights are invaluable as we continue to improve and expand BifroMQ, aiming to offer the most robust and feature-rich messaging solution\\navailable."},{"id":"bifromq-topic-subscription","metadata":{"permalink":"/blog/bifromq-topic-subscription","editUrl":"https://github.com/apache/bifromq-sites/tree/master/blog","source":"@site/blog/2023-12-04-bifromq-topic-subscription-mechanism.mdx","title":"BifroMQ\'s Topic Subscription Mechanism","description":"Introduction","date":"2023-12-04T00:00:00.000Z","tags":[{"inline":true,"label":"BifroMQ","permalink":"/blog/tags/bifro-mq"},{"inline":true,"label":"MQTT","permalink":"/blog/tags/mqtt"},{"inline":true,"label":"Topic","permalink":"/blog/tags/topic"},{"inline":true,"label":"TopicFilter","permalink":"/blog/tags/topic-filter"},{"inline":true,"label":"Subscription","permalink":"/blog/tags/subscription"},{"inline":true,"label":"Serverless","permalink":"/blog/tags/serverless"},{"inline":true,"label":"Multi-Tenant","permalink":"/blog/tags/multi-tenant"}],"readingTime":11.56,"hasTruncateMarker":true,"authors":[{"name":"Yonny(Yu) Hao","url":"https://github.com/popduke","imageURL":"https://github.com/popduke.png","key":"HaoYu","page":null}],"frontMatter":{"slug":"bifromq-topic-subscription","title":"BifroMQ\'s Topic Subscription Mechanism","authors":["HaoYu"],"tags":["BifroMQ","MQTT","Topic","TopicFilter","Subscription","Serverless","Multi-Tenant"]},"unlisted":false,"prevItem":{"title":"BifroMQ 3.0.0 Beta: Enhanced Messaging with MQTT 5.0","permalink":"/blog/bifromq-version-3"},"nextItem":{"title":"BifroMQ: Unveiling the Technology for Building Efficient and Available Clusters","permalink":"/blog/bifromq-high-availibility"}},"content":"import MQTTTopicAndTopicFilter from \'./images/2023-12-03-bifromq-topic-subscription-mechanism/MQTT_Topic_TopicFilter.png\';\\nimport TopicExpansionSet from \'./images/2023-12-03-bifromq-topic-subscription-mechanism/TopicExpansionSet.png\';\\nimport OnePass from \'./images/2023-12-03-bifromq-topic-subscription-mechanism/OnePass.png\';\\nimport DistService from \'./images/2023-12-03-bifromq-topic-subscription-mechanism/DistService.png\';\\n\\n\\n## Introduction\\nSince BifroMQ became open source, we have frequently received inquiries about its implementation details for Topic subscription matching. In the MQTT Pub/Sub mechanism, Topic subscription matching is undoubtedly one of the core functionalities. In BifroMQ, the management of subscription information and the processing of message Topic matching are handled by a dedicated service module called Dist Service (**bifromq-dist**). Given that BifroMQ is designed to support the construction of large-scale, multi-tenant Serverless systems, this critical component faces many complex challenges, particularly in the distributed processing of subscription information (TopicFilter) and the associated Topic matching algorithms. This article will delve into the design decision behind the BifroMQ Topic subscription matching scheme and its implementation in Dist Service.\\n\\n\x3c!--truncate--\x3e\\n\\n## MQTT\'s Topic and TopicFilter\\nIn this section, we shall briefly revisit two fundamental concepts in MQTT related to Topic subscription and matching: *Topic* and *TopicFilter*. During the publication (Pub) process in MQTT, a *Topic* is used to identify the specific subject of a message. Conversely, during the subscription (Sub) process, a *TopicFilter* is employed to denote the intention to subscribe to a series of subjects. This article will distinctly differentiate these two concepts: *Topic* and *TopicFilter*.\\nBoth *Topic* and *TopicFilter* are UTF-8 strings, akin to file directory paths, examples being \u201c`/a/b/c`\u201d, \u201c`/a/b/c/`\u201d, \u201c`/+/b/c`\u201d, and \u201c`+/b/#`\u201d. In these strings, \u201c`/`\u201d serves as the separator for each \'directory\' or *TopicLevel*. The primary difference between *TopicFilter* and *Topic* lies in the character set of the *TopicLevel*: *TopicFilter* permits the use of wildcard characters \u201c`+`\u201d and \u201c`#`\u201d as standalone *TopicLevel*s. These wildcards represent the logic for matching a range of topics. The \u201c`+`\u201d symbol is a single-level wildcard character (Single-level Wildcard Character), which can appear in any position (e.g., \u201c`+`\u201d, \u201c`/+`\u201d, \u201c`+/+`\u201d) and is used to match all *TopicLevel*s at that particular level. The \u201c`#`\u201d symbol, on the other hand, is a multi-level wildcard character (Multi-level Wildcard Character), and can only appear as the last TopicLevel (e.g., \u201c`#`\u201d, \u201c`/#`\u201d, \u201c`+/+/#`\u201d, \u201c`+/#`\u201d), used to match the specified level and all subsequent levels of TopicLevels.\\n*TopicFilter* matches *Topics* in a left-to-right sequence. Here are some examples from the MQTT specification to illustrate this point:\\nFirst, let\'s consider the application of the single-level wildcard \u201c`+`\u201d. Suppose a client subscribes to \u201c`sport/+/player1`\u201d; it will receive messages published under the following Topic names:\\n* \u201c`sport/tennis/player1`\u201d\\n* \u201c`sport/badminton/player1`\u201d\\n* \u201c`sport/golf/player1`\u201d\\nHowever, it will not receive messages for \u201c`sport/tennis/player2`\u201d or \u201c`sport/tennis/player1/ranking`\u201d.\\nSimilarly, if a client subscribes to \u201c``+/tennis/player1`\u201d, it will receive messages for:\\n* \u201c`sport/tennis/player1`\u201d\\n* \u201c`world/tennis/player1`\u201d\\nBut it will not receive messages for \u201c`sport/tennis/player2`\u201d or \u201c`sport/badminton/player1`\u201d.\\nNext, let\u2019s consider the multi-level wildcard \u201c`#`\u201d. For example, if a client subscribes to \u201c`sport/tennis/player1/#`\u201d, it will receive messages published under:\\n* \u201c`sport/tennis/player1`\u201d\\n* \u201c`sport/tennis/player1/ranking`\u201d\\n* \u201c`sport/tennis/player1/score/wimbledon`\u201d\\n\\nImportant points to note when using \u201c`#`\u201d include:\\n* \u201c`sport/#`\u201d will also match the singular \u201c`sport`\u201d, as \u201c`#`\u201d includes the parent level.\\n* Subscribing to \u201c`#`\u201d alone will match all Topics and receive messages on all subjects.\\n* \u201c`sport/tennis/#`\u201d is valid, while \u201c`sport/tennis#`\u201d and \u201c`sport/tennis/#/ranking`\u201d are not valid.\\n\\nThese examples clearly demonstrate how *TopicFilter*s in MQTT can precisely and flexibly match specific ranges or types of messages.\\n\\nIt is noteworthy that the process of matching *TopicFilter* to a *Topic* can logically organize the *TopicFilter* into a Trie(or Tree) data structure, with the matching process being accomplished through tiered searching within the *TopicFilter* Trie. Special handling rules are applied when encountering special wildcard characters such as \u201c`+`\u201d and \u201c`#`\u201d. Below is a brief description of this process:\\n<img src={MQTTTopicAndTopicFilter} style={{width: \'100%\'}} />\\nNote:\\n* Each node within the *TopicFilter* Trie represents a string of a *TopicLevel*, which is different from the traditional String Prefix [\'Trie\'](https://en.wikipedia.org/wiki/Trie) where each node denotes a single character.\\n* When a *TopicFilter* does not contain any wildcard characters, its matching scope is limited to specific message topic. In such cases, a simple Map structure can be employed for subscription matching.\\n* As per MQTT protocol, Topics starting with \u201c$\u201d are considered specially reserved system topics. These topics are not matched by wildcards and are specifically ignored during the search process.\\n\\n## Scenarios Faced by BifroMQ\\nIn this chapter, we will explore the specific scenarios and challenges BifroMQ faces when dealing with the *TopicFilter* Trie.\\nIn typical implementations, the *TopicFilter* Trie is physically organized as a Trie (or Tree) structure in memory. In a distributed environment, each MQTT Broker node locally stores a complete replica of the *TopicFilter* Trie and maintains consistency among the nodes through inter-cluster communication. Given that read requests (i.e., matching operations) for the *TopicFilter* Trie are much more frequent than write requests (updates), traditional implementations allow the topic matching process to occur entirely locally, thus saving the round-trip time of remote access. However, this approach has two potential limitations:\\n1. The size of the *TopicFilter* Trie is limited by the storage resources of a single node.\\n2. When adding new nodes, it is necessary to fully synchronize the *TopicFilter* Trie from other nodes, and the preparation time for the startup process is directly proportional to the size of the Trie.\\n\\nFor most enterprise-level application scenarios, these potential issues are usually not a concern, as the scale of subscriptions is unlikely to reach the upper limit of a single node\'s resources. However, in cloud service environments, especially in Multi-Tenant Serverless service scenarios that BifroMQ aims to support, this traditional approach is no longer suitable. The main reasons include:\\n1. One common issue in multi-tenant scenarios is that the *TopicFilter* Trie becomes too large, exceeding the resource limits of a single node. This situation is especially prevalent in scenarios with a large number of IoT devices, such as SmartHome business, or due to improper subscription behavior and testing activities.\\n2. A large *TopicFilter* Trie usually indicates a business peak hours, necessitating rapid scaling so that new nodes can be quickly in service. However, fully synchronizing the Trie consumes preparation time during startup.\\n\\nTherefore, BifroMQ needs to explore solutions different from the classic approach to better adapt to the needs of building Multi-Tenant Serverless services. The core challenges of this new solution include:\\n1. How to achieve the distribution of the *TopicFilter* Trie.\\n2. How to efficiently perform matching operations in a distributed environment.\\n\\nAddressing these challenges involves a completely new design of the storage mode and algorithms for the *TopicFilter* Trie, which we refer to as the \'**OnePass**\' method.\\n\\n## The \\"OnePass\\" Solution\\nIn an in-depth analysis of MQTT\'s topic matching rules, we observe a significant characteristic: for any given *Topic*, all possible *TopicFilter*s that can match that *Topic* form a specific set. We refer to this set as the ***TopicFilter* ExpansionSet**(or ExpansionSet briefly) for a particular *Topic*. The following figure illustrates this concept:\\n<img src={TopicExpansionSet} style={{width: \'100%\'}} />\\n\\nThe ExpansionSet of particular *Topic* can also be represented using a Trie structure. In this structure, nodes at the same level are sorted in byte order. By performing an in-order traversal of the Trie of the ExpansionSet, we can obtain all possible *TopicFilter* strings arranged in lexicographical order. It\'s important to note that during the comparison process, the delimiter \'`/`\' is not considered, or it can be replaced with a Unicode `null` character (\'`\\\\u0000`\'). The size of the ExpansionSet (i.e., the number of possible TopicFilters) is related to the number of levels in the *Topic* and can be determined by the formula `F(x) = 6*2^x - 1`, with its space complexity being O(2^x), increasing geometrically with the number of levels.\\n\\nHowever, for a specific *Topic*, the actual subscriptions that occur are just a small subset of its ExpansionSet. Therefore, we can store the subscriptions that actually occur within the system, using *TopicFilter* as a key prefix, in an ordered KV storage engine. In BifroMQ, this storage engine is implemented by **base-kv** -- The embedded distributed KV storage engine for building stateful services in BifroMQ. The storage mode of the *TopicFilter* Trie, formed by subscriptions, can be simplified as follows:\\n* key: `<TenantId><0x00><TopicFilter><SessionId>`\\n* value: `<MetadataAboutTheSubscription>`\\n\\nUsing ordered KV storage, it is easy to achieve the distribution of the *TopicFilter* Trie logically formed by actual subscriptions. In BifroMQ, we utilize the sharding capability of base-kv to achieve this: subscriptions are distributed and balanced among nodes based on certain strategies, according to the load characteristics of topic subscription matching. During system scaling, new nodes only need to synchronize a portion of the shard replicas, eliminating the need to synchronize all subscription data, thereby meeting the requirements for rapid scaling.\\n\\nAfter organizing subscription data into an ordered KV form, the next question is how to implement MQTT\'s Topic matching logic. Specifically, when an MQTT Pub message is received, how can we find all the subscription records matching the message\'s Topic through the read operation of KV storage? This process can be transformed into a mathematical Set problem: finding the intersection of the set formed by the *Topic*\'s ExpansionSet and the set of *TopicFilter*s from the actual subscriptions in the current system. This is easily achievable!\\n<img src={OnePass} style={{width: \'100%\'}} />\\nAs shown in the figure, the left side displays the lexigraphical order ExpansionSet for the topic \\"`a/b/c`\\", while the right side shows the current subscription relationships in the system, presented in an ordered KV storage format.\\n\\nThe core workflow of the matching algorithm involves sequentially scanning the subscription relationship KV on the right from top to bottom, and locating the position of the currently subscribed *TopicFilter* in the ExpansionSet on the left. If the *TopicFilter* exists in the left ExpansionSet, a match is considered found. If it does not exist, and assuming the next possible matching *TopicFilter* in the left ExpansionSet is `T`, the algorithm can skip all parts in the right-side ordered KV of subscription relationships that have a lexicographical order less than T, and then continue scanning.\\n\\nThis algorithm operates unidirectionally on both the left and right sets, so the completion of scanning in either set signifies the end of the algorithm.\\n\\nFrom the perspective of space complexity, the left ExpansionSet essentially serves as an \'index\' and does not need to be actually expanded in memory. It only needs to identify the next possible *TopicFilter* that might appear in the right set according to the lexicographical order expansion rule, hence the space overhead of the left set can be neglected. The right set represents the actual existing subscription relationships in the current system, with its space complexity being `O(N)``, where `N` is the number of subscriptions.\\n\\nThe time complexity of the algorithm is related to the number of actual subscription relationships, with an upper limit of approximately `O(N*log(X))``, where `X` is the number of levels in the Topic. Of course, the worst-case scenario occurs when the right set includes every possible subscription for all Topics.\\n\\nSince the algorithm only requires a single efficient scan of the subscription relationship KV storage data during execution, we have named this approach \'**OnePass**\'.\\n\\n## The Dist Service\\nDist Service (**bifromq-dist**) is a key sub-service within BifroMQ for handling subscriptions and message routing distribution, with the \'OnePass\' scheme forming the core of its sub-service architecture.\\n\\nDist Service comprises two server modules: DistServer and DistWorker. DistServer is a stateless RPC service module responsible for handling request scheduling; whereas DistWorker is a stateful module, incorporating a KV storage engine (base-kv), within which distributed storage of subscriptions data is implemented.\\n\\nTo reduce the latency costs associated with internal communication during message routing and distribution, Dist Service is designed to tightly couple data with computation. The term \'data\' here has a dual meaning: it refers both to the MQTT Pub messages themselves and to subscriptions data. \'Computation,\' on the other hand, pertains to the subscription matching and message distribution process. Dist Worker encapsulates the topic matching and distribution process of messages into the base-kv\'s Range CoProcessor, ensuring that the matching and distribution processes occur locally where the subscription information is stored. Such a design effectively prevents additional data transmission from impacting the latency of messages within the BifroMQ system.\\n<img src={DistService} style={{width: \'100%\'}} />\\nThe above figure demonstrates the role played by DistService in handling MQTT Pub/Sub. To enhance the efficiency of subscription matching, Dist Worker has further optimized the \'OnePass\' scheme, notably through the introduction of a caching mechanism. Under this mechanism, for messages continuously published under the same *Topic*, only a single execution of the \'OnePass\' algorithm process is required. The results of the matching are cached for use in subsequent similar requests. This introduction of caching not only speeds up processing but also reduces the overhead of repeated computations and local IO. It is important to note, however, that the invalidation and update strategies associated with caching are complex and fall beyond the scope of this discussion, thus they are not elaborated in detail in this article.\\n\\n## Conclusion\\nTopic subscription matching is a core feature of the MQTT protocol, and its flexibility is a key factor in MQTT\'s widespread application. However, the implementation solutions accumulated over the years by the community and industry have shown certain limitations in dealing with Multi-Tenant Serverless service scenarios. BifroMQ\'s \'OnePass\' scheme, based on [First Principle](https://en.wikipedia.org/wiki/First_principle) and starting from an architectural perspective, is an attempt to address this issue. We hope this approach can bring new inspiration to the community and drive the development and innovation of technology."},{"id":"bifromq-high-availibility","metadata":{"permalink":"/blog/bifromq-high-availibility","editUrl":"https://github.com/apache/bifromq-sites/tree/master/blog","source":"@site/blog/2023-12-01-bifromq-high-availability.mdx","title":"BifroMQ: Unveiling the Technology for Building Efficient and Available Clusters","description":"Introduction","date":"2023-12-01T00:00:00.000Z","tags":[{"inline":true,"label":"BifroMQ","permalink":"/blog/tags/bifro-mq"},{"inline":true,"label":"Open Source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"MQTT","permalink":"/blog/tags/mqtt"},{"inline":true,"label":"High Availability","permalink":"/blog/tags/high-availability"},{"inline":true,"label":"Technical Architecture","permalink":"/blog/tags/technical-architecture"},{"inline":true,"label":"Cluster","permalink":"/blog/tags/cluster"},{"inline":true,"label":"Distributed Key-Value","permalink":"/blog/tags/distributed-key-value"},{"inline":true,"label":"Load Balancing","permalink":"/blog/tags/load-balancing"}],"readingTime":14.76,"hasTruncateMarker":true,"authors":[{"name":"Yonny(Yu) Hao","url":"https://github.com/popduke","imageURL":"https://github.com/popduke.png","key":"HaoYu","page":null},{"name":"Ma Fei","url":"https://github.com/mafei6827","imageURL":"https://github.com/mafei6827.png","key":"MaFei","page":null}],"frontMatter":{"slug":"bifromq-high-availibility","title":"BifroMQ: Unveiling the Technology for Building Efficient and Available Clusters","authors":["HaoYu","MaFei"],"tags":["BifroMQ","Open Source","MQTT","High Availability","Technical Architecture","Cluster","Distributed Key-Value","Load Balancing"]},"unlisted":false,"prevItem":{"title":"BifroMQ\'s Topic Subscription Mechanism","permalink":"/blog/bifromq-topic-subscription"},"nextItem":{"title":"BifroMQ StandardCluster","permalink":"/blog/bifromq-standardcluster"}},"content":"import AutoEviction from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-AutoEviction.png\';\\nimport BrainSplit from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-BrainSplit.png\';\\nimport Domain from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-Domain.png\';\\nimport DynamicConfig from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-DynamicConfig.png\';\\nimport IndependentWorkload from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-IndependentWorkload.png\';\\nimport Join from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-Join.png\';\\nimport LeaderBalance from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-LeaderBalance.png\';\\nimport RangeBalancer from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-RangeBalancer.png\';\\nimport RangeLeaderBalancer from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-RangeLeaderBalancer.png\';\\nimport RangeSplit from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-RangeSplit.png\';\\nimport RangeSplitBalancer from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-RangeSplitBalancer.png\';\\nimport RecoveryBalancer from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-RecoveryBalancer.png\';\\nimport ReplicaCntBalancer from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-ReplicaCntBalancer.png\';\\nimport RPCCluster from \'./images/2023-12-01-bifromq-high-availability/BifroMQ-RPCCluster.png\';\\n\\n\\n\\n## Introduction\\nThe cluster version of BifroMQ has been launched in the community lately, meeting the core demands of users for horizontal scaling and high availability in cluster deployment. We have previously detailed the capabilities of [BifroMQ StandardCluster](2023-10-24-bifromq-standardcluster.mdx) in terms of performance scaling. In this article, we will focus on a deep analysis of the technical features adopted by BifroMQ to ensure high availability.\\n\\n\x3c!--truncate--\x3e\\n\\n## Decentralized Clusters\\nIn the architecture of BifroMQ, we have meticulously designed a scheme for partitioning the MQTT protocol workload. This strategy allows each type of workload to operate in its own independent sub-cluster. These functional sub-clusters are all built upon a sophisticated decentralized base-cluster framework. The cluster framework of BifroMQ consists of two logical layers: the Underlay Cluster and the Overlay Cluster. Such a construction makes the architecture clear and decoupled. For more details about this design, please refer to the [\'BifroMQ Technical Architecture Overview\'](2023-09-06-bifromq-architecture-overview.md).\\n\\n### Underlay Cluster\\nThe Underlay Cluster is the core of the BifroMQ cluster system, with its members representing a running BifroMQ process, and members can communicate directly using the host network address bound to the process. We adopt a Gossip-based Membership protocol (SWIM Protocol) for cluster member failure detection, and have further optimized the synchronization mechanism for Membership information, providing the following technical characteristics:\\n* Cluster construction does not depend on traditional registration centers or naming services, effectively eliminating the operational risks of single points of failure, significantly enhancing the cluster\'s high availability.\\n* Using the SWIM protocol, the Underlay Cluster ensures the accuracy of node probing mechanisms between nodes, maintaining the final consistency of the cluster topology.\\n* Using CRDT technology to synchronize Membership information between nodes, achieving extremely low bandwidth usage and timely synchronization.\\n\\n#### Cluster Construction Process\\nIn a decentralized cluster architecture, each cluster member has an equal status, with no special node designated to manage cluster topology information. From a higher perspective, any node running the BifroMQ StandardCluster service process can be seen as an independent cluster with a \\"single node.\\" Thus, the construction of the cluster is essentially the fusion of these independent clusters. To facilitate this process, the base-cluster framework provides a \\"join\\" operation for the effective merging of these independent clusters.\\n<img src={Join} style={{width: 700}} />\\n\\nAs shown in the illustration above, the join operation of a cluster can be initiated by any node to any node in the target cluster. For simplicity, we refer to the nodes targeted in the join operation as \\"seeds.\\" In a typical deployment process, the addresses of these seed nodes are usually configured in the [configuration file](/docs/admin_guide/configuration/config_file_manual/) (seedEndpoints) of the new nodes joining the cluster. After the successful merging of the clusters, each node in the BifroMQ cluster can obtain complete cluster Membership information locally.\\n\\nAttentive readers may have noticed that directly specifying seed addresses in node configuration may have certain limitations in a containerized environment. To address this issue, the base-cluster framework has built-in DNS resolution functionality. In container environments, we can simplify the cluster deployment process by including all nodes in a fixed network Domain (such as External DNS or Kubernetes Service). Thus, new nodes can use any Remote address resolved from this Domain as the seed to complete the join process.\\n<img src={Domain} style={{width: 700}} />\\n\\n#### FailureDetection and Auto-Eviction\\nIn BifroMQ, when a node exits normally, it actively clears its registered identity in the cluster and synchronizes this change with other nodes in the cluster. Additionally, each node continuously performs failure detection of other nodes. Once anomalies are detected, the node immediately removes the relevant information of that node from its local cluster Membership and quickly completes the synchronization of Membership information across the cluster, preventing these inactive nodes from affecting the normal function of the cluster.\\n<img src={AutoEviction} style={{width: 500}} />\\n\\nIn conjunction with the automatic eviction mechanism, BifroMQ also has a built-in self-healing mechanism which effectively prevents the erroneous removal of registration information of healthy nodes due to network jitters or misjudgments: each node re-examines its registration information when it observes changes in cluster information. If missing information(about itself) is found, the node will actively supplement it, thus ensuring the integrity and final consistency of cluster information.\\n\\n#### Recovery from Split-Brain\\nFor decentralized cluster services, network partition-induced brain splits, where a single cluster divides into multiple isolated clusters, are an unavoidable issue.\\n\\nThe base-cluster ensures protection against potential brain split failures, further enhancing the high availability of cluster deployment. Here\'s how it works: When a network partition happens, the isolated cluster segments detect node failures in the other segments. These failed nodes get added to a \'healing list\' in their respective segments. The system periodically tries to rejoin these nodes from the list until the time exceeds the MTTR(Mean Time To Repair) set during deployment. Notably, this recovery process from brain splits follows a similar pattern to the initial cluster construction.\\n<img src={BrainSplit} style={{width: 500}} />\\n\\n### Overlay Cluster\\nThe Overlay Cluster, also known as the Agent Cluster, is built on top of the Underlay Cluster. It utilizes the capabilities of the Underlay Cluster for Membership management and inter-member communication, primarily serving as the cluster for specific functional services. Thanks to the efficient construction mechanism of the Underlay Cluster, the Agent Cluster can automatically form the cluster, significantly simplifying the deployment and operational processes.\\n\\nIn BifroMQ, the functional service clusters implemented by the Agent Cluster can be classified into two categories: stateless clusters mainly comprising RPC services, and stateful clusters typically built on the embedded distributed KV storage engine(base-kv).\\n\\n#### RPC Service Cluster\\nMembers of the RPC service cluster are usually defined as client and server roles. With the features of the Agent Cluster, the client and server of the RPC do not depend on external registration centers, enabling efficient server discovery and flexible client request routing logic.\\n<img src={RPCCluster} style={{width: 700}} />\\n\\n#### Stateful Service Cluster and Distributed KV Storage Engine\\nBifroMQ\'s stateful service cluster is built on top of the strong consistency distributed KV storage engine--base-kv. This engine features sharding capabilities based on Multi-Raft, making it a key component of BifroMQ\'s high reliability. The Membership information of the cluster is maintained by the Agent Cluster, while each Range shard within the cluster achieves strong consistency synchronization through the Raft protocol. Therefore, to ensure the high reliability of stateful services, it is essential to fully utilize and comply with the characteristics of the Raft protocol.\\n\\n##### KVRange Balancer\\nThe base-kv uses a built-in Range Balancer framework for efficient management of Range replicas. This framework takes into account the current cluster topology and various real-time load information to generate commands for balancing the Range replica set. These commands include LeaderTransfer, MemberConfigurationChange, RangeSplit, and RangeMerge. Through this series of operations, base-kv can effectively balance the cluster load, optimize throughput, and achieve the goal of high availability.\\nIt is worth mentioning that the Range Balancer also adopts a decentralized design principle. In each node of base-kv, the Balancer is only responsible for managing the local Leader Range. This design allows Balancers on multiple nodes to operate in parallel, ultimately achieving a globally consistent balancing goal.\\n<img src={RangeBalancer} style={{width: 600}} />\\n\\nBifroMQ has pre-built a range of common load balancing strategies for out-of-box usage. However, for advanced users with specific needs, BifroMQ also offers the capability to customize load balancing strategies (via Balancer SPI), allowing for optimization according to specific application workload scenarios. Below is a brief introduction to the built-in open-source balancers. Users can activate these strategies as needed through configuration.\\n\\n**ReplicaCntBalancer**\\n\\nThe primary function of the ReplicaCntBalancer is to adjust and balance the number of replicas of a Range within a cluster deployment. Once enabled, this feature allows the number of Range replicas to be flexibly adjusted according to the number of deployment nodes in the BifroMQ StandardCluster cluster. This means that the ReplicaCntBalancer can automatically optimize and achieve the best availability configuration according to the current scale of the cluster, to reduce the cluster operation work.\\n<img src={ReplicaCntBalancer} style={{width: 700}} />\\n\\nAs shown above, the working process is as follows:\\n* Cluster scale-up: Suppose initially there are 3 nodes in the BifroMQ cluster, and the number of Range replicas is also 3, allowing the cluster to tolerate the failure of 1 node. When 2 more nodes are added to the cluster, the ReplicaCntBalancer automatically incorporates these new nodes into the replica configuration, and after data synchronization, the number of replicas increases to 5. This allows the cluster to tolerate the unavailability of 2 nodes, thus enhancing the cluster\'s fault tolerance.\\n* Cluster scale-down: In another scenario, when the BifroMQ cluster contains 5 nodes and the number of Range replicas is also 5, if two nodes crash, the cluster can still operate normally according to the Raft algorithm. However, if the replica configuration remains unchanged, another node\'s crash will cause the entire Raft cluster to become inoperable. At this point, the ReplicaCntBalancer will adjust the replica configuration to include only the remaining 3 available nodes. This adjustment ensures that the cluster remains highly available even if one more node becomes unavailable.\\n\\n**RangeSplitBalancer**\\n\\nIn BifroMQ, each Range\'s replica set is managed through the Raft protocol, and its load capacity is limited by the WAL replication mechanism, thus having a certain performance ceiling. Especially when application workloads are highly concentrated on a single Range, this limitation becomes particularly apparent. In such cases, splitting a Range into multiple parts is an effective way to enhance the system\'s parallel task handling capability, thereby improving the overall system performance.\\n\\nThe RangeSplitBalancer is the built-in load balancing strategy in base-kv that implements this functionality. It analyzes the actual application workload and timely generates Range splitting instructions, thereby optimizing system processing capacity and enhancing performance.\\n<img src={RangeSplitBalancer} style={{width: 600}} />\\n\\n**RangeLeaderBalancer**\\n\\nIn the Raft protocol, the Leader node handles all write requests and some read requests. Therefore, when the Leader replicas of multiple Ranges are concentrated on the same node, it can easily create load hotspots, affecting system performance. To address this issue, the base-kv cluster can activate the RangeLeaderBalancer in situations where multiple Ranges are splitting.\\n\\nThe RangeLeaderBalancer is specifically responsible for monitoring and adjusting the distribution of Range leader replicas across nodes. It achieves balance by migrating Ranges between nodes, ensuring an even distribution of Leader replicas on each base-kv node.\\n<img src={RangeLeaderBalancer} style={{width: 600}} />\\n\\n**RecoveryBalancer**\\n\\nIn non-Byzantine fault-tolerant strong consistency protocols, the number of functioning nodes n must satisfy the condition n \u2265 2f+1, where f represents the number of fail-tolerant nodes. Based on this principle, any Range replica must be located in more than half of the normal cluster nodes to ensure proper operation. However, in actual deployment, when there are many Ranges in the cluster and a single base-kv node may carry replicas of multiple different Ranges, simultaneous failures of multiple cluster nodes could lead to a situation where n < 2f+1, known as Lost Majority. In the event of Lost Majority, the affected Ranges will be unable to operate normally.\\n\\nTo deal with this situation, the RecoveryBalancer provides a opt-in capability. It allows nodes to detect if they are in a Lost Majority state and, if necessary, actively reduce the replica list configuration to ensure that at least half of the nodes are alive, thus enabling the Range to continue functioning. However, it is important to note that the recovery process is beyond the scope of Raft protocol when using RecoveryBalancer to automatically recover Ranges in a Lost Majority state, if the originally failed nodes rejoin the cluster without manual intervention, it may lead to data loss and inconsistency issues. In such cases, users need to carefully consider and combine actual operational strategies to decide whether to enable the RecoveryBalancer in their deployment.\\n<img src={RecoveryBalancer} style={{width: 700}} />\\n\\n### Stateful Functional Services\\nBifroMQ\'s stateful sub-services come in three types: MQTT subscription routing, offline message queues, and retain message storage. These are implemented by corresponding modules: dist-worker, inbox-store, and retain-store, respectively. Each module, once deployed, forms an independent base-kv cluster.\\n\\nTo adapt to various workload demands, BifroMQ allows each independent cluster to select and initiate suitable Balancer strategies based on its specific conditions. This flexible configuration of strategies ensures that each cluster maintains high availability while achieving optimal data processing and throughput performance.\\n\\n#### dist-worker\\nIn BifroMQ\'s architecture, the dist-worker module is responsible for managing subscription information (Sub) and message distribution (Pub). In normal use cases, this is typically a scenario dominated by read operations with fewer write operations.\\n\\nConsidering this workload pattern, the dist-worker adopts the following default Balancer strategies:\\n* Enabling dynamic replica count: This strategy ensures that the number of KVRange replicas is consistent with the number of cluster nodes, maximizing query throughput efficiency.\\n* Limiting voter replica count: While ensuring high availability, the number of Raft Voters is limited to a maximum of three. Other replicas serve as Learners, reducing the response latency of write operations.\\n\\nIn most common use cases, the number of subscribers that a Publish message matches is usually not large, and the matching process is relatively fast. Given this, the dist-worker module does not activate the Range splitting strategy in its default configuration.\\n\\nHowever, in scenarios where messages require large-scale Fanout, especially when low latency is also a requirement, the query efficiency of a single Range could become a bottleneck for overall performance. To address these challenges, we plan to enhance this aspect of processing capability in future versions of BifroMQ to optimize performance in handling message fanout to large scale subscribers.\\n\\n#### retain-store\\nNormally retain-store has similar workload characteristic as dist-worker, so the default Balancer strategy same and will not be reiterated here.\\n\\n#### inbox-store\\nIn BifroMQ, the inbox-store module takes on the role of managing offline messages for each connection with cleanSession=false. For these connections, inbox-store creates a dedicated persistent offline message queue. Subscribed messages are first written into this queue. When the connection goes back online, messages are pulled from the queue for delivery and subsequently deleted. This is a typical scenario with frequent read and write, where the workload is mainly concentrated on the Leader replica, and the IO latency of storage significantly impacts system message throughput.\\n\\nConsidering this kind of workload pattern, the default Balancer strategies for the inbox-store are as follows:\\n* Limiting the Voter to 1 by default: As a higher number of replicas can lead to increased write response latency, the default setting limits the number of Range replicas to 1. This prioritizes rapid message processing but comes with some reliability trade-offs. Users can adjust the number of replicas based on their needs.\\n* Enabling range split and leader balancing: This strategy allows the inbox-store to dynamically shard and expand as the workload gradually increases, ultimately achieving a more balanced load distribution.\\n\\n## Notes on BifroMQ StandardCluster Deployment\\nBifroMQ StandardCluster adopts a deployment strategy that integrates all functional modules into a single process. This strategy simplifies the configuration and deployment process, similar to the \'SharedNothing\' cluster architecture commonly used in the industry. However, because multiple modules share the same system resources allocated for one process, this limits the ability to \\"fine-tune\\" the allocation based on actual application needs. All modules need to be scaled up or down uniformly, which may not be suitable for cloud scenarios, where different types of workload fluctuations are time-related and require more detailed and flexible resource management.\\n\\n## From BifroMQ StandardCluster To IndependentWorkload Cluster\\nThe unique architectural design of BifroMQ enables it to easily implement a deployment mode of \'independent process per module\', which we call the IndependentWorkload Cluster (to be introduced in future versions). This mode not only offers greater flexibility and more precise resource management capabilities, but it also helps users to gradually transition from the StandardCluster mode to the IndependentWorkload Cluster mode in line with the development of business. Such a progressive deployment change can optimize resource allocation and respond to fluctuations in business demands while maintaining business continuity.\\n<img src={IndependentWorkload} style={{width: 700}} />\\n\\n## Conclusion\\nThe above content provides a comprehensive introduction to the high-availability technology of BifroMQ. BifroMQ ensures the overall high availability of its clusters through the implementation of various mechanisms. Please look forward to a series of upcoming specialized articles where we will delve deeper into the various components of BifroMQ and their design principles, offering you more in-depth technical insights."},{"id":"bifromq-standardcluster","metadata":{"permalink":"/blog/bifromq-standardcluster","editUrl":"https://github.com/apache/bifromq-sites/tree/master/blog","source":"@site/blog/2023-10-24-bifromq-standardcluster.mdx","title":"BifroMQ StandardCluster","description":"Since the first release of BifroMQ, it has gained wide attention from the community. Among them, cluster capability has been highly anticipated and also one of the top priorities for the BifroMQ team. After three months of tireless efforts, we officially released the cluster version of BifroMQ, which we call the Standard Cluster. The Standard Cluster is the main cluster mode supported in the open source version of BifroMQ, where each node has full MQTT protocol capabilities under this mode. At the same time, HTTP API is also supported in this version","date":"2023-10-24T00:00:00.000Z","tags":[{"inline":true,"label":"BifroMQ","permalink":"/blog/tags/bifro-mq"},{"inline":true,"label":"Open Source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"MQTT","permalink":"/blog/tags/mqtt"},{"inline":true,"label":"Cluster","permalink":"/blog/tags/cluster"}],"readingTime":5.94,"hasTruncateMarker":true,"authors":[{"name":"Yonny(Yu) Hao","url":"https://github.com/popduke","imageURL":"https://github.com/popduke.png","key":"HaoYu","page":null}],"frontMatter":{"slug":"bifromq-standardcluster","title":"BifroMQ StandardCluster","authors":"HaoYu","tags":["BifroMQ","Open Source","MQTT","Cluster"]},"unlisted":false,"prevItem":{"title":"BifroMQ: Unveiling the Technology for Building Efficient and Available Clusters","permalink":"/blog/bifromq-high-availibility"},"nextItem":{"title":"BifroMQ Technical Architecture Overview","permalink":"/blog/bifromq-tech-architecture"}},"content":"import StandardCluster from \'./images/2023-10-24-bifromq-standardcluster/BifroMQ-StandardCluster.png\';\\nimport DistSubCluster from \'./images/2023-10-24-bifromq-standardcluster/BifroMQ-Dist-SubCluster.png\';\\nimport InboxSubCluster from \'./images/2023-10-24-bifromq-standardcluster/BifroMQ-Inbox-SubCluster.png\';\\nimport LoadBasedSplitter from \'./images/2023-10-24-bifromq-standardcluster/BifroMQ-Inbox-LoadBasedSplitter.png\';\\nimport APIService from \'./images/2023-10-24-bifromq-standardcluster/BifroMQ-API-Service.png\';\\n\\nSince the first release of BifroMQ, it has gained wide attention from the community. Among them, cluster capability has been highly anticipated and also one of the top priorities for the BifroMQ team. After three months of tireless efforts, we officially released the cluster version of BifroMQ, which we call the **Standard Cluster**. The Standard Cluster is the main cluster mode supported in the open source version of BifroMQ, where each node has full MQTT protocol capabilities under this mode. At the same time, HTTP API is also supported in this version\\n\\n\x3c!--truncate--\x3e\\n\\n## TLDR:\\n* Installation [package](https://github.com/bifromqio/bifromq/releases/) and Deployment [instructions](/docs/cluster/standardcluster/)\\n\x3c!-- * Test [report](/docs/test_report/report/) --\x3e\\n* API [documentation](/docs/user_guide/api/intro/)\\n\\n## Overall Structure of the Standard Cluster\\nIn a previous architecture overview [article](2023-09-06-bifromq-architecture-overview.md), we mentioned that BifroMQ logically divides MQTT functionalities into several sub-services, each corresponding to a critical workload:\\n* bifromq-mqtt: Responsible for MQTT protocol connection workloads.\\n* bifromq-dist: Manages subscription and message routing distribution workloads.\\n* bifromq-inbox: Handles offline message queues within persistent sessions.\\n* bifromq-retain: Manages the storage and retrieval of Retain messages.\\n\\nFrom a deployment perspective, BifroMQ StandardCluster encapsulates these independent workload service modules into a cluster mode within a single node service process, and logically, this can be seen as an abstraction of the Standalone operating mode (BifroMQ Standalone can be considered as a single-node version of BifroMQ StandardCluster). Unlike other MQTT Brokers that support clustering, BifroMQ incorporates built-in distributed persistence functionality, making each individual BifroMQ node \\"stateful.\\"\\n\\n<img src={StandardCluster} style={{width: 700}} />\\n\\n*Note: In all illustrations in this article, the text within brackets, \\"bifromq-xxx,\\" corresponds to the module names in the code.*\\n\\n## Horizontal Scaling of Message Distribution Capability\\nIn the Standard Cluster mode, the Dist Service module within each node process forms a logically partitioned subset cluster of workloads (Dist-SubCluster). Dist Service stores subscription information in a built-in persistence engine and synchronizes routing information between nodes using the persistence engine\'s distributed capabilities. In Standard Cluster mode, horizontal scaling of message distribution capability can be achieved by adding nodes, especially when CleanSession is set to True.\\n\\n<img src={DistSubCluster} style={{width: 700}} />\\n\\n## Persistence, Scalability, and High Reliability of Offline Message Queues\\nSimilar to the Dist Service module, the Inbox Service module within node processes, responsible for offline message queues within MQTT persistent sessions, forms another logically partitioned subset cluster of workloads (Inbox-SubCluster). Inbox Service persists offline queue messages in the built-in storage engine, significantly reducing data loss due to node failures. In terms of storage, Inbox Service leverages the sharding capability of the built-in storage engine, allowing horizontal scaling of storage capacity and processing power. Additionally, by dynamically increasing the number of shard replicas through static configuration or runtime policies, the reliability of offline message data can be further enhanced, which is especially important for applications with higher data reliability requirements.\\n\\n<img src={InboxSubCluster} style={{width: 700}} />\\n\\n*Note 1: Due to the significant impact of increasing shard replica count on message workloads when MQTT CleanSession is set to False, resource allocation must be determined based on actual needs, with the default replica count set to 1, which can be adjusted through the JVM startup parameter `inbox_store_range_voter_count`.*\\n\\n*Note 2: The Inbox Service provides global access to offline message queues, allowing MQTT clients to access offline messages in their respective queues when reconnecting to any cluster node, eliminating the need for the common \\"sticky session\\" or \\"session migration\\" solutions often found in other MQTT Broker cluster implementations.*\\n\\n## Load-Based Splitting Strategy for Inbox Service\\nAs previously mentioned, in a Standard Cluster deployment, the Inbox Service within a single node process utilizes the sharding capability of the built-in storage engine to achieve horizontal scaling of storage capacity and processing power. However, the sharding strategy has a decisive impact on actual performance. In BifroMQ Standard Cluster, we have incorporated an out-of-the-box load-based splitting strategy. This strategy determines the partitioning of KV Ranges based on load conditions over a recent period, serving as a \\"posterior\\" splitting strategy. When the usage scenario has already been planned and understood for the distribution of offline message workloads, pre-partitioning typically results in more stable performance when the workload arrives. For advanced BifroMQ users, prior splitting strategies can be implemented through the SPI mechanism.\\n\\n<img src={LoadBasedSplitter} style={{width: 400}} />\\n\\n## HTTP API Module\\nBifroMQ StandardCluster introduces the HTTP API feature. Each cluster node can open an API access port through configuration. BifroMQ HTTP API is a stateless global interface designed to support the integration of management control logic at the business level. Accessing the API of any node allows operations on the entire cluster. For more details, please refer to [this link](/docs/user_guide/api/intro/).\\n\\n<img src={APIService} style={{width: 700}} />\\n\\n## Impact of Mixed Workloads on Performance\\nIn a Standard Cluster deployment, a single node possesses complete MQTT protocol functionality, handling various types of workloads. Therefore, this mode is particularly suitable for two types of enterprise-level application scenarios:\\n1. Workloads generated by the business are relatively uniform.\\n2. The business generates a diverse range of workloads, but they are relatively evenly distributed in time.\\n   For cases where workloads are complex and generated centrally in terms of time, we recommend that users perform load testing to determine the optimal resource configuration and parameter settings for a single BifroMQ Standard Cluster cluster or consider using multiple BifroMQ Standard Clusters to handle different types of business workloads. Additionally, you can reach out to us for support with BifroMQ Independent-Workload Cluster in the BifroMQ commercial version.\\n\\n## Deployment and Operations\\nIn a previous BifroMQ technical architecture article, we mentioned that BifroMQ clusters are built on a decentralized technology (base-cluster), eliminating the need for external node registration and discovery services. As a result, the deployment process for building a BifroMQ Standard Cluster is straightforward (for detailed instructions, please refer to [this link](/docs/cluster/standardcluster/)). It only requires designating any node in a cluster as a seed node to enable the addition of new nodes. Furthermore, BifroMQ includes self-healing capabilities in the event of cluster partitioning, greatly simplifying operational tasks during network partition and other failures.\\n\\n## Future Outlook\\nThe BifroMQ team adheres to a neutral technology philosophy, dedicated to the large-scale implementation of the MQTT protocol, as well as improving reliability and maintainability. We look forward to more community participation and in-depth user feedback to collectively advance this technology. Additionally, you can join the developer community by [emailing](mailto:hello@bifromq.io) us your WeChat ID, along with more information on why BifroMQ has caught your attention (we\'d love to hear about it), or by joining our Discord group via this [link](https://discord.gg/Pfs3QRadRB)."},{"id":"bifromq-tech-architecture","metadata":{"permalink":"/blog/bifromq-tech-architecture","editUrl":"https://github.com/apache/bifromq-sites/tree/master/blog","source":"@site/blog/2023-09-06-bifromq-architecture-overview.md","title":"BifroMQ Technical Architecture Overview","description":"In today\'s IoT field, the MQTT protocol has become an indispensable key element, providing core technical support for efficient and real-time data transmission. However, projects that currently offer MQTT capabilities are mainly concentrated on traditional, existing \\"out-of-the-box\\" IoT device management platforms, leading to a lack of sufficient attention and exploration of the underlying MQTT protocol implementation. However, we firmly believe that the characteristics of the MQTT protocol have a broader application prospect, not limited to the IoT field. It is out of this belief that after years of practice and technical accumulation, we have launched the open-source project BifroMQ, focusing on the efficient processing of the MQTT protocol, especially in the face of large-scale loads.","date":"2023-09-06T00:00:00.000Z","tags":[{"inline":true,"label":"BifroMQ","permalink":"/blog/tags/bifro-mq"},{"inline":true,"label":"MQTT Broker","permalink":"/blog/tags/mqtt-broker"},{"inline":true,"label":"Serverless","permalink":"/blog/tags/serverless"},{"inline":true,"label":"Multi-Tenancy","permalink":"/blog/tags/multi-tenancy"},{"inline":true,"label":"Architecture","permalink":"/blog/tags/architecture"}],"readingTime":7.36,"hasTruncateMarker":true,"authors":[{"name":"Yonny(Yu) Hao","url":"https://github.com/popduke","imageURL":"https://github.com/popduke.png","key":"HaoYu","page":null}],"frontMatter":{"slug":"bifromq-tech-architecture","title":"BifroMQ Technical Architecture Overview","authors":"HaoYu","tags":["BifroMQ","MQTT Broker","Serverless","Multi-Tenancy","Architecture"]},"unlisted":false,"prevItem":{"title":"BifroMQ StandardCluster","permalink":"/blog/bifromq-standardcluster"},"nextItem":{"title":"AnyAuth and Integration with BifroMQ","permalink":"/blog/AnyAuth and Integration with BifroMQ"}},"content":"In today\'s IoT field, the MQTT protocol has become an indispensable key element, providing core technical support for efficient and real-time data transmission. However, projects that currently offer MQTT capabilities are mainly concentrated on traditional, existing \\"out-of-the-box\\" IoT device management platforms, leading to a lack of sufficient attention and exploration of the underlying MQTT protocol implementation. However, we firmly believe that the characteristics of the MQTT protocol have a broader application prospect, not limited to the IoT field. It is out of this belief that after years of practice and technical accumulation, we have launched the open-source project BifroMQ, focusing on the efficient processing of the MQTT protocol, especially in the face of large-scale loads.\\n\\n\x3c!--truncate--\x3e\\n\\n**Neutral and Scalable MQTT Protocol Middleware**\\n\\nCompared to traditional IoT device management platforms, BifroMQ adheres to a different design philosophy. We boldly abandon the traditional paradigm of \\"one-size-fits-all solutions\\" and focus on the needs of high-performance MQTT protocols. We believe that the characteristics of the MQTT protocol have a broader application paradigm, so BifroMQ is committed to fully exploiting the potential of the MQTT protocol, especially in terms of excellent performance when handling large-scale loads.\\n\\nCompared to integrating logic with downstream systems (such as Kafka) in MQTT implementations, BifroMQ prefers to \\"dock\\" with downstream systems in a way that complies with MQTT standards. For example, through the Shared Subscription mechanism, the integration logic is externalized to achieve more decoupled bridging and the ability to forward messages to heterogeneous systems while maintaining high message throughput. This design philosophy makes BifroMQ a highly customizable middleware that can easily adapt to various downstream systems to meet the needs of different business scenarios.\\n\\n## Building Large-Scale Multi-Tenant Serverless Cloud Services\\n\\nThe mission of BifroMQ is to build an MQTT messaging system suitable for large-scale multi-tenant use to support the business characteristics of Serverless-type cloud services. This mission is driven by a deep understanding of the characteristics of the MQTT protocol and confidence in its broader application. Unlike traditional enterprise architectures, Serverless cloud services emphasize resource allocation on demand, elastic expansion, and highly flexible service construction. Therefore, BifroMQ, through its multi-tenant architecture and resource sharing mechanism, provides the feature of \\"shared resources, exclusive experience\\" for Serverless-type businesses.\\n\\n## Enterprise Deployment: Flexibility and Robustness\\n\\nAlthough the goal of BifroMQ is to build multi-tenant Serverless cloud services, multi-tenant + shared resources are essentially an abstraction of single-tenant exclusive resources. Consistent with our philosophy, BifroMQ easily supports common \\"Shared Nothing\\" enterprise-level cluster deployments through the free combination and configuration of core components. In fact, this is also the default deployment mode of the open-source version of BifroMQ. This flexibility allows BifroMQ to adapt to system architectures of various scales and needs.\\n\\n## BifroMQ Architecture Analysis\\n\\nThe architectural design of BifroMQ is based on \\"first principles,\\" analyzing the technologies needed to achieve design goals from a technical perspective and how to organically combine these technologies to achieve overall optimization. Therefore, it is difficult to fully understand its connotation just from the project structure and code logic. The following will describe the overall architecture of BifroMQ from three main angles.\\n\\n### Modular Architecture Based on Decentralized Cluster Management\\n\\n**Firstly**, apart from the implementation logic of the MQTT protocol itself, the various functional service modules of BifroMQ are built on a set of decentralized underlying cluster construction capabilities (base-cluster), as shown in the following figure:\\n\\n![Modular architecture of BifroMQ\'s decentralized cluster](images/2023-09-06-bifromq-architecture-overview/bifromq-architecture-1.png)\\n\\n<p class=\\"text-gray-400 text-center\\">Modular architecture of BifroMQ\'s decentralized cluster</p>\\n\\nThe cluster logic constructed by base-cluster is logically divided into two layers: Underlay Cluster and Overlay Cluster. The Underlay Cluster is called the \\"Host\\" Cluster, and each Host in BifroMQ corresponds to a service process (Process) running on the operating system. The Host Cluster uses Gossip-like protocols (SWIM Protocol) to implement Host Membership and provides an abstract Host address for the Overlay Cluster. The Overlay Cluster is called the \\"Agent\\" Cluster, which provides an Agent-level address abstraction (Agent Address) based on the Host address. In BifroMQ, the Agent corresponds to a logical service (Service) that implements specific functions. These logical services (unifiedly implemented through the base-rpc framework) include client and server role modules, which use the capabilities of the Agent Cluster to achieve service registration and discovery.\\n\\nThe benefits of this architecture include:\\n\\n1. Logical services are decoupled from the processes in which they are located, allowing for more flexible encapsulation and combination according to deployment scenarios.\\n2. The \\"service discovery\\" of logical services does not depend on traditional registration centers or name services, thereby eliminating the operational risk of single-point failures and allowing the cluster scale to freely expand.\\n\\n### Modular Load Isolation and Collaboration\\n\\n**Next**, we describe the structure of BifroMQ from the perspective of protocol implementation. When architecting from the perspective of building Serverless cloud services, it is necessary to consider the rationality of functional implementation from the perspective of load isolation and management, that is, the multi-tenancy of the load. We have split the workload of the MQTT protocol so that each type of load can exist in the form of an independent sub-cluster, and these sub-clusters build complete MQTT capabilities through collaboration. The following are the MQTT load-related modules in BifroMQ:\\n\\n* bifromq-mqtt: Responsible for handling the long-connection load of the MQTT protocol\\n* bifromq-dist: Responsible for maintaining the high-reliability storage and large-scale message routing of MQTT subscription status\\n* bifromq-inbox: Responsible for the high-reliability storage of subscriber session messages in CleanSession=false mode\\n* bifromq-retain: Responsible for the high-reliability storage of Retain messages\\n\\nThe collaboration relationship between these modules is shown in the following figures:\\n\\n![BifroMQ Module Collaboration Relationship 1](images/2023-09-06-bifromq-architecture-overview/bifromq-architecture-2-1.png)\\n![BifroMQ Module Collaboration Relationship 2](images/2023-09-06-bifromq-architecture-overview/bifromq-architecture-2-2.png)\\n\\n<p class=\\"text-gray-400 text-center\\">BifroMQ Module Collaboration Relationship</p>\\n\\n\\nIt is worth mentioning that the bifromq-dist, bifromq-inbox, and bifromq-retain modules all make full use of the capabilities of base-kv to achieve distributed strong consistency persistence of key loads. In the operation and maintenance scenarios of Serverless cloud services, this is particularly important for ensuring SLA.\\n\\n### Neutrality: Standard-Oriented and Scalable Integration\\n\\nAs mentioned earlier, the positioning of BifroMQ is to implement MQTT standard middleware, emphasizing neutrality and integrability more. It is not on the same level as other projects that include MQTT capabilities as part of a \\"one-size-fits-all IoT platform.\\"\\n\\nTherefore, the standard for judging \\"whether BifroMQ has a certain function or will support a certain function in the future?\\" is very simple: all capabilities defined by the MQTT protocol belong to the scope that the BifroMQ project needs to support, and all functions that exceed the definition of the MQTT protocol, we prefer to exist as independent components or services, and integrate with BifroMQ in a way that complies with MQTT standards. This method helps to build larger-scale cloud services and promote the maturity of related technologies.\\n\\nOf course, the integrability of BifroMQ is also reflected in the integration of the middleware itself with various business systems, mainly including three mechanisms: Plugin, API, and Metrics:\\n\\n![Typical Scenario Integration Architecture](images/2023-09-06-bifromq-architecture-overview/bifromq-architecture-3.png)\\n\\n<p class=\\"text-gray-400 text-center\\">Typical Scenario Integration Architecture</p>\\n\\n* The Plugin mechanism is the main way to implement business logic integration. bifromq currently defines the following plugin interface modules:\\n  * bifromq-plugin-auth-provider: Implement client authentication and Pub/Sub authorization logic based on message topics\\n  * bifromq-plugin-event-collector: Implement business logic triggered by various MQTT-related events\\n  * bifromq-plugin-setting-provider: Implement tenant-level runtime setting change management logic\\n\\n* Reference implementations of these interfaces can be found in the BifroMQ-Inside project.\\n* The API mechanism (coming soon) provides BifroMQ\'s runtime HTTP management interface, implementing basic management operations such as server-side subscription management and disconnection.\\n* The Metrics mechanism implements metric definition and sampling through the use of the micrometer library, but does not limit the type of collector, allowing business integration parties to customize (you can refer to the build-plugin-demo module in the project).\\n\\n### Summary\\n\\nIn summary, this is an overall introduction to the technical architecture of BifroMQ. Please look forward to a series of special articles that we will publish next, to explore the various components and design principles of BifroMQ in depth. At the same time, you are welcome to join the BifroMQ Discord  <a href=\\"https://discord.gg/Pfs3QRadRB\\"><img src=\\"https://img.shields.io/discord/1115542029531885599?logo=discord&logoColor=white\\" alt=\\"BifroMQ Discord server\\" /></a>."},{"id":"AnyAuth and Integration with BifroMQ","metadata":{"permalink":"/blog/AnyAuth and Integration with BifroMQ","editUrl":"https://github.com/apache/bifromq-sites/tree/master/blog","source":"@site/blog/2023-09-04-bifromq-auth-plugin.mdx","title":"AnyAuth and Integration with BifroMQ","description":"The AnyAuth plugin is a powerful extension built upon the BifroMQ IAuthProvider interface using PF4J. It is","date":"2023-09-04T00:00:00.000Z","tags":[{"inline":true,"label":"Auth","permalink":"/blog/tags/auth"},{"inline":true,"label":"Plugin","permalink":"/blog/tags/plugin"}],"readingTime":3.54,"hasTruncateMarker":true,"authors":[{"name":"Gu Jiawei","url":"https://github.com/Gujiawei-Edinburgh","imageURL":"https://github.com/Gujiawei-Edinburgh.png","key":"Jiawei","page":null}],"frontMatter":{"slug":"AnyAuth and Integration with BifroMQ","title":"AnyAuth and Integration with BifroMQ","authors":"Jiawei","tags":["Auth","Plugin"]},"unlisted":false,"prevItem":{"title":"BifroMQ Technical Architecture Overview","permalink":"/blog/bifromq-tech-architecture"},"nextItem":{"title":"BifroMQ officially open source : high-performance multi-tenant MQTT Broker","permalink":"/blog/news-bifromq-opensource"}},"content":"import ReactPlayer from \'react-player\'\\n\\nThe **AnyAuth** plugin is a powerful extension built upon the BifroMQ `IAuthProvider` interface using PF4J. It is\\ndesigned to provide seamless authentication and authorization capabilities for BifroMQ, enabling users to secure access\\nto messages and resources across a wide range of clients.\\n\\n\x3c!--truncate--\x3e\\n\\n## BifroMQ in Smart Home\\n\\n### Background\\nCompany A is a firm specializing in the smart home industry. They aim to enhance their product\'s value and user\\nexperience by incorporating IoT (Internet of Things) technology, allowing remote control of their products. They have\\nchosen BifroMQ as their MQTT message middleware, integrated into their IoT platform to connect their smart home devices\\nto the internet.\\n\\n### Key Participants\\n* Company A: Smart home devices manufacturer looking to enhance product value and user experience through IoT technology.\\n* Company B: Software development company responsible for developing the IoT platform and WeChat Mini Program for\\ncompany A.\\n* BifroMQ: MQTT message middleware providing reliable message transmission services, integrated into the IoT platform\\nby company B.\\n\\n### End Users\\nAs users of the smart home devices, we anticipate the ability to remotely control the devices, e.g. air conditioner,\\nadjust the temperature, check the current indoor temperature, and monitor the air conditioner\'s operational status\\nthrough the WeChat Mini Program.\\n\\n### AnyAuth in BifroMQ\\n\\nThe versatility of the **AnyAuth** plugin lies in its support for various authentication mechanisms, including\\ntraditional username/password that is for devices, auth0, and even WeChat integration. This means that users can be\\nauthenticated by using their preferred social accounts, simplifying access to BifroMQ.\\n\\nFurthermore, **AnyAuth** seamlessly integrates with BifroMQ, offering Role-Based Access Control (RBAC) through\\nAccess Control Lists (ACL). This feature empowers administrators to define distinct roles and permissions, which can\\nthen ensure fine-grained access control.\\n\\nFor more information and technical design, check the [article](https://github.com/Gujiawei-Edinburgh/bifromq-plugin-anyAuth#readme).\\n## Setup Steps\\nIntegrating **AnyAuth** with BifroMQ has proven to be remarkably straightforward. Here\'s a concise rundown to get\\nstarted:\\n\\n### Prerequisites\\nBefore we dive in, it\'s essential to understand that AnyAuth\'s primary focus lies in querying users\' credentials and\\ncorresponding ACL rules. Handling administrative tasks, such as user registration and ACL specification, falls under\\nthe purview of other services. To ensure a smooth data retrieval process, users must complete device registration and\\nspecify ACL requirements in advance.\\n\\n### Configure AnyAuth Plugin\\n\\n**AnyAuth**\'s flexibility hinges on the correct configuration of authentication parameters. These parameters can vary\\ndepending on your chosen authentication method (e.g., username/password, auth0 and WeChat). The configuration file can\\nbe found in the `bifromq-plugin-anyAuth/auth-plugin/src/main/resources` directory and will be packaged into the JAR file\\nafter compilation. Therefore, it\'s crucial to configure it first.\\n```yaml\\ntenantId: ${TENANTID}\\ndevice:\\n  authUrl: ${AUTH_SERVICE_AUTH_URL}\\n  checkUrl: ${AUTH_SERVICE_CHECK_URL}\\nauth0:\\n  domain: ${AUTH0_DOMAIN}\\nwechat:\\n  appId: ${APP_ID}\\n  appSecret: ${APP_SECRET}\\n  requestUrl: https://api.weixin.qq.com/sns/jscode2session?appid=\\n```\\n### Setup BifroMQ with Plugin\\nNow, let\'s move to the practical implementation. In your **AnyAuth** project directory, run the following command to\\ngenerate the necessary output:\\n```mvn\\ncd bifromq-plugin-anyAuth && mvn clean package\\n```\\nThis command will generate an `auth-plugin-${VERSION}.jar` and `auth-service-${VERSION}.tar.gz` file in their respective\\ntarget directories.\\n\\nTo ensure BifroMQ correctly loads the **AnyAuth** plugin, place the corresponding JAR file in the plugins directory\\nwithin BifroMQ\'s target directory, i.e. `bifromq-${VERSION}/plugins`. Additionally, specify the Fully Qualified Name (FQN),\\ne.g. `authProviderFQN: bifromq.plugin.auth.AuthProvider`, in BifroMQ\'s configuration file (`conf/standalone.yml`).\\n\\n### Setup AnyAuth Service\\nThe plugin JAR file acts as a client for authentication and authorization, while the **AnyAuth** service handles database\\nquery operations. Deploy the **AnyAuth** service, specifying MySQL connection parameters for credentials and permission\\nrules queries.\\n\\nFor development or testing purposes, **AnyAuth** also supports dummy storage, i.e. set `type: Dummy` in **AnyAuth**\\nservice configuration file.\\n\\n## End-to-End Demo\\nWith all the setup steps completed, we can now embark on an exciting journey. Utilize a WeChat MiniProgram to log in to\\nBifroMQ, and a user-friendly GUI application to simulate devices. The video below showcases a typical scenario: a device\\nreporting the current temperature via BifroMQ, and a WeChat MiniProgram receiving the message, subsequently issuing\\ncommands based on the data.\\n<div className=\\"video__wrapper\\">\\n    <ReactPlayer className=\\"video__player\\" controls height=\\"100%\\"\\n    url=\\"https://github.com/Gujiawei-Edinburgh/bifromq-plugin-anyAuth/assets/55412783/df9f9009-e96f-4c97-b25a-aa399196fbd9\\"\\n    width=\\"100%\\" />\\n</div>"},{"id":"news-bifromq-opensource","metadata":{"permalink":"/blog/news-bifromq-opensource","editUrl":"https://github.com/apache/bifromq-sites/tree/master/blog","source":"@site/blog/2023-07-07-bifromq-opensource-pr.md","title":"BifroMQ officially open source : high-performance multi-tenant MQTT Broker","description":"BifroMQ is a high-performance distributed MQTT messaging middleware that seamlessly integrates native multi-tenancy support. It is designed to facilitate the construction of large-scale Internet of Things (IoT) device connections and messaging systems.","date":"2023-07-07T00:00:00.000Z","tags":[{"inline":true,"label":"BifroMQ","permalink":"/blog/tags/bifro-mq"},{"inline":true,"label":"Open Source","permalink":"/blog/tags/open-source"},{"inline":true,"label":"MQTT","permalink":"/blog/tags/mqtt"},{"inline":true,"label":"Serverless","permalink":"/blog/tags/serverless"},{"inline":true,"label":"Multi-Tenancy","permalink":"/blog/tags/multi-tenancy"}],"readingTime":4.34,"hasTruncateMarker":true,"authors":[{"name":"Yonny(Yu) Hao","url":"https://github.com/popduke","imageURL":"https://github.com/popduke.png","key":"HaoYu","page":null}],"frontMatter":{"slug":"news-bifromq-opensource","title":"BifroMQ officially open source : high-performance multi-tenant MQTT Broker","authors":"HaoYu","tags":["BifroMQ","Open Source","MQTT","Serverless","Multi-Tenancy"]},"unlisted":false,"prevItem":{"title":"AnyAuth and Integration with BifroMQ","permalink":"/blog/AnyAuth and Integration with BifroMQ"}},"content":"BifroMQ is a high-performance distributed MQTT messaging middleware that seamlessly integrates native multi-tenancy support. It is designed to facilitate the construction of large-scale Internet of Things (IoT) device connections and messaging systems.\\n\\n\x3c!--truncate--\x3e\\n\\n<div align=\\"center\\">\\n    <img src=\\"https://images.unsplash.com/photo-1562575214-ffefa379432a?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=600&q=80\\" alt=\\"BifroMQ\\" width=\\"60%\\" />\\n    <br />\\n    <br />\\n</div>\\n\\nServing as the foundational middleware for Baidu AI Cloud [IoT Core](https://cloud.baidu.com/product/iot.html), BifroMQ plays a critical role in supporting large-scale device connections and message transmissions within Baidu\'s IoT technology stack. With the BifroMQ-based public cloud cluster service, Baidu AI Cloud IoT Core Suite has already served thousands of enterprise developers, connected billions of devices, and handled massive message throughput. This is attributed to BifroMQ\u2019s standalone and horizontally scalable design, enabling it to effectively manage crucial MQTT workloads, including connection and messaging loads.\\n\\nAfter years of technological accumulation and refinement by Baidu AI Cloud IoT team, BifroMQ now fully supports MQTT 3.1/3.1.1, including connectivity via TCP, TLS, WS, and WSS, and is also on the verge of supporting MQTT 5.0. This endows BifroMQ with significant advantages in compatibility and standard implementation.\\n\\nTo propel the remarkable development of the Internet industry and foster the growth of BifroMQ, Baidu is officially open-sourcing BifroMQ from today!\\n\\n## Why is it called BifroMQ?\\n\\nThe name BifroMQ is inspired by `Bifr\xf6st` from Norse mythology - a rainbow bridge connecting the human world Midgard and the realm of the gods Asgard, serving as a sturdy and flexible conduit between the two worlds. Similarly, BifroMQ aims to be a hub connecting various systems or applications, enabling communication between them through message passing. This mirrors the role of MQTT middleware in distributed systems, which involves handling and forwarding messages.\\n\\nMoreover, BifroMQ\u2019s exceptional performance in stability and reliability, along with its advantages in scalability and adaptability, closely resemble the sturdiness and flexibility of `Bifr\xf6st`. Hence, we named the MQTT middleware `BifroMQ` to symbolize its role as a solid yet adaptable bridge connecting different systems or applications.\\n\\n## BifroMQ Architecture and Performance\\n\\nBifroMQ is an open-source MQTT Broker built on the concept of Serverless. Its design philosophy is \\"shared resources, exclusive experience,\\" focusing on solving workload isolation and supply-demand balance in multi-tenant environments. It employs a load-independent sub-cluster design, effectively handling connection sessions, message forwarding, and message storage workloads. The sub-clusters are highly available, support horizontal scaling, and can adeptly cater to multi-tenant scenarios. To overcome the issue of routing table sizes potentially exceeding single-machine memory, we employed an innovative design that allows the routing table storage to scale across multiple machines. Additionally, BifroMQ includes an optimized distributed storage engine, eliminating the dependence on third-party storage middleware and ensuring stable performance.\\n\\nFurthermore, BifroMQ supports Independent Workload Cluster, Standard Cluster, and Standalone deployment modes, and allows customization through plugins to meet various business requirements.\\n\\nIn terms of performance, BifroMQ has undergone rigorous testing, demonstrating formidable processing capabilities and low latency. In a standard testing environment dealing with a large volume of concurrent message publishing, BifroMQ maintained extremely low message latency and relatively low CPU usage. Compared to other open-source MQTT messaging middlewares, BifroMQ excels in latency and performance stability.\\n\\n## BifroMQ Use Cases\\n\\nBifroMQ can be widely employed in various IoT scenarios, including but not limited to smart homes, industrial IoT,\\n\\nconnected vehicles, and smart cities. It offers reliable, high-performance messaging services, supporting large-scale device connections and message processing. For instance, in the smart home sector, BifroMQ enables the integration of tens of millions of home devices and supports remote control, status synchronization, and data reporting. In the industrial IoT domain, it facilitates real-time data collection and processing from a vast number of sensors and devices. In the connected vehicles segment, BifroMQ can handle communication between vehicles as well as between vehicles and infrastructure. In smart city applications, it assists in managing and optimizing urban resources such as traffic, energy, and security for enhanced public services.\\n\\n## Future Prospects\\n\\nBifroMQ is highly valued at Baidu and will receive Baidu\'s full support and extensive resource investments. Moving forward, BifroMQ will continue to improve its support for MQTT 5, enhance performance optimization, enrich functionalities, and constantly expand its applications in the IoT domain. Additionally, we will uphold the principle of technological neutrality, further strengthening BifroMQ\u2019s integration capabilities, enabling it to more effortlessly collaborate with various systems and applications. Furthermore, BifroMQ will cooperate with more open-source projects and standardization organizations in the future to collectively advance the development of IoT technologies and contribute to the global IoT industry\'s evolution.\\n\\nLastly, as an open-source project, BifroMQ warmly welcomes developers and enterprises to actively participate in project development and enhancement. To facilitate this, we have provided an abundance of resources such as documentation, tutorials, Q&A, and code contributions on the BifroMQ official website ([https://bifromq.io/](https://bifromq.io/)) and the GitHub community platform ([https://github.com/bifromqio/bifromq](https://github.com/bifromqio/bifromq)). \\n\\nAdditionally, you can also join our Discord group.\\n<a href=\\"https://discord.gg/Pfs3QRadRB\\"><img src=\\"https://img.shields.io/discord/1115542029531885599?logo=discord&logoColor=white\\" alt=\\"BifroMQ Discord server\\" /></a>"}]}}')}}]);